// Copyright 2017 Alexander Bolz
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#include <cassert>
#include <cstdint>
#include <cstdio>
#include <cstring>
#include <limits>

#if defined(_MSC_VER)
#include <intrin.h>
#endif

#ifndef CC_ASSERT
#define CC_ASSERT(X) assert(X)
#endif

// 0: Numbers of the form ...5000...0 round upwards.
// 1: Numbers of the form ...5000...0 round towards even. (Match double-conversion.)
#define CC_DTOA_ROUND_TO_NEAREST_EVEN 1

#if defined(_M_IX86) || defined(_M_ARM) || defined(__i386__) || defined(__arm__)
#define CC_32_BIT_PLATFORM 1
#else
// Assume 64-bit platform
#endif

#if defined(__GNUC__) && defined(__SIZEOF_INT128__)
#define CC_HAS_UINT128 1
#elif defined(_MSC_VER) && defined(_M_X64)
#define CC_HAS_64_BIT_INTRINSICS 1
#endif

namespace charconv_internal {

//==================================================================================================
// IEEE double-/single-precision inspection
//==================================================================================================

template <typename Dest, typename Source>
inline Dest ReinterpretBits(Source source)
{
    static_assert(sizeof(Dest) == sizeof(Source), "size mismatch");

    Dest dest;
    std::memcpy(&dest, &source, sizeof(Source));
    return dest;
}

struct Double
{
    static_assert(std::numeric_limits<double>::is_iec559
		          && std::numeric_limits<double>::digits == 53
                  && std::numeric_limits<double>::max_exponent == 1024,
        "IEEE-754 double-precision implementation required");

    static constexpr int      SignificandSize         = std::numeric_limits<double>::digits;    // = p   (includes the hidden bit)
    static constexpr int      PhysicalSignificandSize = SignificandSize - 1;                    // = p-1 (excludes the hidden bit)
    static constexpr int      UnbiasedMinExponent     = 1;
    static constexpr int      UnbiasedMaxExponent     = 2 * std::numeric_limits<double>::max_exponent - 1 - 1;
    static constexpr int      ExponentBias            = 2 * std::numeric_limits<double>::max_exponent / 2 - 1 + (SignificandSize - 1);
    static constexpr int      MinExponent             = UnbiasedMinExponent - ExponentBias;
    static constexpr int      MaxExponent             = UnbiasedMaxExponent - ExponentBias;
    static constexpr uint64_t HiddenBit               = uint64_t{1} << (SignificandSize - 1);   // = 2^(p-1)
    static constexpr uint64_t SignificandMask         = HiddenBit - 1;                          // = 2^(p-1) - 1
    static constexpr uint64_t ExponentMask            = uint64_t{2 * std::numeric_limits<double>::max_exponent - 1} << PhysicalSignificandSize;
    static constexpr uint64_t SignMask                = ~(~uint64_t{0} >> 1);

    uint64_t /*const*/ bits;

    explicit Double(uint64_t bits_) : bits(bits_) {}
    explicit Double(double value) : bits(ReinterpretBits<uint64_t>(value)) {}

    uint64_t PhysicalSignificand() const {
        return bits & SignificandMask;
    }

    uint64_t PhysicalExponent() const {
        return (bits & ExponentMask) >> PhysicalSignificandSize;
    }

    bool IsFinite() const {
        return (bits & ExponentMask) != ExponentMask;
    }

    bool IsInf() const {
        return (bits & ExponentMask) == ExponentMask && (bits & SignificandMask) == 0;
    }

    bool IsNaN() const {
        return (bits & ExponentMask) == ExponentMask && (bits & SignificandMask) != 0;
    }

    bool IsZero() const {
        return (bits & ~SignMask) == 0;
    }

    bool SignBit() const {
        return (bits & SignMask) != 0;
    }

    double Value() const {
        return ReinterpretBits<double>(bits);
    }

    double AbsValue() const {
        return ReinterpretBits<double>(bits & ~SignMask);
    }

	double NextValue() const {
        assert(!SignBit());
        return ReinterpretBits<double>(IsInf() ? bits : bits + 1);
    }
};

//==================================================================================================
// Itoa helper
//==================================================================================================

inline char* Utoa_2Digits(char* buf, uint32_t digits)
{
    static constexpr char const* kDigits100 =
        "00010203040506070809"
        "10111213141516171819"
        "20212223242526272829"
        "30313233343536373839"
        "40414243444546474849"
        "50515253545556575859"
        "60616263646566676869"
        "70717273747576777879"
        "80818283848586878889"
        "90919293949596979899";

    CC_ASSERT(digits < 100);
    std::memcpy(buf, kDigits100 + 2*digits, 2 * sizeof(char));
    return buf + 2;
}

inline char* Utoa_4Digits(char* buf, uint32_t digits)
{
    CC_ASSERT(digits < 10000);
    uint32_t const q = digits / 100;
    uint32_t const r = digits % 100;
    Utoa_2Digits(buf + 0, q);
    Utoa_2Digits(buf + 2, r);
    return buf + 4;
}

inline char* Utoa_8Digits(char* buf, uint32_t digits)
{
    CC_ASSERT(digits < 100000000);
    uint32_t const q = digits / 10000;
    uint32_t const r = digits % 10000;
    Utoa_4Digits(buf + 0, q);
    Utoa_4Digits(buf + 4, r);
    return buf + 8;
}

inline int Pow5BitLength(int e) // e == 0 ? 1 : ceil(log_2(5^e))
{
    CC_ASSERT(e >= 0);
    CC_ASSERT(e <= 1500); // Only tested for e <= 1500
    return static_cast<int>((static_cast<uint32_t>(e) * 1217359) >> 19) + 1;
}

inline int Log10Pow2(int e) // floor(log_10(2^e))
{
    CC_ASSERT(e >= 0);
    CC_ASSERT(e <= 1500); // Only tested for e <= 1500
    return static_cast<int>((static_cast<uint32_t>(e) * 78913) >> 18);
}

inline int Log10Pow5(int e) // floor(log_10(5^e))
{
    CC_ASSERT(e >= 0);
    CC_ASSERT(e <= 1500); // Only tested for e <= 1500
    return static_cast<int>((static_cast<uint32_t>(e) * 732923) >> 20);
}

//==================================================================================================
// DoubleToDecimal
//
// Implements the Ryu algorithm for (IEEE) binary to decimal floating-point conversion.
//
// This implementation is a slightly modified version of the
// implementation by Ulf Adams which can be obtained from
// https://github.com/ulfjack/ryu
//
// The license can be found below.
//
// References:
//
// [1]  Adams, "Ryu: fast float-to-string conversion",
//      PLDI 2018 Proceedings of the 39th ACM SIGPLAN Conference on Programming Language Design and Implementation Pages 270-282
//      https://dl.acm.org/citation.cfm?id=3192369
//==================================================================================================

/*
Copyright 2018 Ulf Adams

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

// sizeof(tables) = 9888 bytes

struct Uint64x2 {
    uint64_t lo;
    uint64_t hi;
};

constexpr int kPow5InvDoubleBitLength = 122;
constexpr int kPow5DoubleBitLength = 121;
constexpr int kPow5InvDoubleTableSize = 292;
constexpr int kPow5DoubleTableSize = 326;

static constexpr Uint64x2 kPow5InvDouble[kPow5InvDoubleTableSize] = { // 4672 bytes
    {0x0000000000000001, 0x0400000000000000},
    {0x3333333333333334, 0x0333333333333333},
    {0x28F5C28F5C28F5C3, 0x028F5C28F5C28F5C},
    {0xED916872B020C49C, 0x020C49BA5E353F7C},
    {0xAF4F0D844D013A93, 0x0346DC5D63886594},
    {0x8C3F3E0370CDC876, 0x029F16B11C6D1E10},
    {0xD698FE69270B06C5, 0x0218DEF416BDB1A6},
    {0xF0F4CA41D811A46E, 0x035AFE535795E90A},
    {0xF3F70834ACDAE9F1, 0x02AF31DC4611873B},
    {0x5CC5A02A23E254C1, 0x0225C17D04DAD296},
    {0xFAD5CD10396A2135, 0x036F9BFB3AF7B756},
    {0xFBDE3DA69454E75E, 0x02BFAFFC2F2C92AB},
    {0x2FE4FE1EDD10B918, 0x0232F33025BD4223},
    {0x4CA19697C81AC1BF, 0x0384B84D092ED038},
    {0x3D4E1213067BCE33, 0x02D09370D4257360},
    {0x643E74DC052FD829, 0x024075F3DCEAC2B3},
    {0x6D30BAF9A1E626A7, 0x039A5652FB113785},
    {0x2426FBFAE7EB5220, 0x02E1DEA8C8DA92D1},
    {0x1CEBFCC8B9890E80, 0x024E4BBA3A487574},
    {0x94ACC7A78F41B0CC, 0x03B07929F6DA5586},
    {0xAA23D2EC729AF3D7, 0x02F394219248446B},
    {0xBB4FDBF05BAF2979, 0x025C768141D369EF},
    {0xC54C931A2C4B758D, 0x03C7240202EBDCB2},
    {0x9DD6DC14F03C5E0B, 0x0305B66802564A28},
    {0x4B1249AA59C9E4D6, 0x026AF8533511D4ED},
    {0x44EA0F76F60FD489, 0x03DE5A1EBB4FBB15},
    {0x6A54D92BF80CAA07, 0x0318481895D96277},
    {0x21DD7A89933D54D2, 0x0279D346DE4781F9},
    {0x362F2A75B8622150, 0x03F61ED7CA0C0328},
    {0xF825BB91604E810D, 0x032B4BDFD4D668EC},
    {0xC684960DE6A5340B, 0x0289097FDD7853F0},
    {0xD203AB3E521DC33C, 0x02073ACCB12D0FF3},
    {0xE99F7863B696052C, 0x033EC47AB514E652},
    {0x87B2C6B62BAB3757, 0x02989D2EF743EB75},
    {0xD2F56BC4EFBC2C45, 0x0213B0F25F69892A},
    {0x1E55793B192D13A2, 0x0352B4B6FF0F41DE},
    {0x4B77942F475742E8, 0x02A8909265A5CE4B},
    {0xD5F9435905DF68BA, 0x022073A8515171D5},
    {0x565B9EF4D6324129, 0x03671F73B54F1C89},
    {0xDEAFB25D78283421, 0x02B8E5F62AA5B06D},
    {0x188C8EB12CECF681, 0x022D84C4EEEAF38B},
    {0x8DADB11B7B14BD9B, 0x037C07A17E44B8DE},
    {0x7157C0E2C8DD647C, 0x02C99FB46503C718},
    {0x8DDFCD823A4AB6CA, 0x023AE629EA696C13},
    {0x1632E269F6DDF142, 0x0391704310A8ACEC},
    {0x44F581EE5F17F435, 0x02DAC035A6ED5723},
    {0x372ACE584C1329C4, 0x024899C4858AAC1C},
    {0xBEAAE3C079B842D3, 0x03A75C6DA27779C6},
    {0x6555830061603576, 0x02EC49F14EC5FB05},
    {0xB7779C004DE6912B, 0x0256A18DD89E626A},
    {0xF258F99A163DB512, 0x03BDCF495A9703DD},
    {0x5B7A614811CAF741, 0x02FE3F6DE212697E},
    {0xAF951AA00E3BF901, 0x0264FF8B1B41EDFE},
    {0x7F54F7667D2CC19B, 0x03D4CC11C5364997},
    {0x32AA5F8530F09AE3, 0x0310A3416A91D479},
    {0xF55519375A5A1582, 0x0273B5CDEEDB1060},
    {0xBBBB5B8BC3C3559D, 0x03EC56164AF81A34},
    {0x2FC916096969114A, 0x03237811D593482A},
    {0x596DAB3ABABA743C, 0x0282C674AADC39BB},
    {0x478AEF622EFB9030, 0x0202385D557CFAFC},
    {0xD8DE4BD04B2C19E6, 0x0336C0955594C4C6},
    {0xAD7EA30D08F014B8, 0x029233AAAADD6A38},
    {0x24654F3DA0C01093, 0x020E8FBBBBE454FA},
    {0x3A3BB1FC346680EB, 0x034A7F92C63A2190},
    {0x94FC8E635D1ECD89, 0x02A1FFA89E94E7A6},
    {0xAA63A51C4A7F0AD4, 0x021B32ED4BAA52EB},
    {0xDD6C3B607731AAED, 0x035EB7E212AA1E45},
    {0x1789C919F8F488BD, 0x02B22CB4DBBB4B6B},
    {0xAC6E3A7B2D906D64, 0x022823C3E2FC3C55},
    {0x13E390C515B3E23A, 0x03736C6C9E606089},
    {0xDCB60D6A77C31B62, 0x02C2BD23B1E6B3A0},
    {0x7D5E7121F968E2B5, 0x0235641C8E52294D},
    {0xC8971B698F0E3787, 0x0388A02DB0837548},
    {0xA078E2BAD8D82C6C, 0x02D3B357C0692AA0},
    {0xE6C71BC8AD79BD24, 0x0242F5DFCD20EEE6},
    {0x0AD82C7448C2C839, 0x039E5632E1CE4B0B},
    {0x3BE023903A356CFA, 0x02E511C24E3EA26F},
    {0x2FE682D9C82ABD95, 0x0250DB01D8321B8C},
    {0x4CA4048FA6AAC8EE, 0x03B4919C8D1CF8E0},
    {0x3D5003A61EEF0725, 0x02F6DAE3A4172D80},
    {0x9773361E7F259F51, 0x025F1582E9AC2466},
    {0x8BEB89CA6508FEE8, 0x03CB559E42AD070A},
    {0x6FEFA16EB73A6586, 0x0309114B688A6C08},
    {0xF3261ABEF8FB846B, 0x026DA76F86D52339},
    {0x51D691318E5F3A45, 0x03E2A57F3E21D1F6},
    {0x0E4540F471E5C837, 0x031BB798FE8174C5},
    {0xD8376729F4B7D360, 0x027C92E0CB9AC3D0},
    {0xF38BD84321261EFF, 0x03FA849ADF5E061A},
    {0x293CAD0280EB4BFF, 0x032ED07BE5E4D1AF},
    {0xEDCA240200BC3CCC, 0x028BD9FCB7EA4158},
    {0xBE3B50019A3030A4, 0x02097B309321CDE0},
    {0xC9F88002904D1A9F, 0x03425EB41E9C7C9A},
    {0x3B2D3335403DAEE6, 0x029B7EF67EE396E2},
    {0x95BDC291003158B8, 0x0215FF2B98B6124E},
    {0x892F9DB4CD1BC126, 0x035665128DF01D4A},
    {0x07594AF70A7C9A85, 0x02AB840ED7F34AA2},
    {0x6C476F2C0863AED1, 0x0222D00BDFF5D54E},
    {0x13A57EACDA3917B4, 0x036AE67966562217},
    {0x0FB7988A482DAC90, 0x02BBEB9451DE81AC},
    {0xD95FAD3B6CF156DA, 0x022FEFA9DB1867BC},
    {0xF565E1F8AE4EF15C, 0x037FE5DC91C0A5FA},
    {0x911E4E608B725AB0, 0x02CCB7E3A7CD5195},
    {0xDA7EA51A0928488D, 0x023D5FE9530AA7AA},
    {0xF7310829A8407415, 0x039566421E7772AA},
    {0x2C2739BAED005CDE, 0x02DDEB68185F8EEF},
    {0xBCEC2E2F24004A4B, 0x024B22B9AD193F25},
    {0x94AD16B1D333AA11, 0x03AB6AC2AE8ECB6F},
    {0xAA241227DC2954DB, 0x02EF889BBED8A2BF},
    {0x54E9A81FE35443E2, 0x02593A163246E899},
    {0x2175D9CC9EED396A, 0x03C1F689EA0B0DC2},
    {0xE7917B0A18BDC788, 0x03019207EE6F3E34},
    {0xB9412F3B46FE393A, 0x0267A8065858FE90},
    {0xF535185ED7FD285C, 0x03D90CD6F3C1974D},
    {0xC42A79E57997537D, 0x03140A458FCE12A4},
    {0x03552E512E12A931, 0x02766E9E0CA4DBB7},
    {0x9EEEB081E3510EB4, 0x03F0B0FCE107C5F1},
    {0x4BF226CE4F740BC3, 0x0326F3FD80D304C1},
    {0xA3281F0B72C33C9C, 0x02858FFE00A8D09A},
    {0x1C2018D5F568FD4A, 0x020473319A20A6E2},
    {0xF9CCF48988A7FBA9, 0x033A51E8F69AA49C},
    {0xFB0A5D3AD3B99621, 0x02950E53F87BB6E3},
    {0x2F3B7DC8A96144E7, 0x0210D8432D2FC583},
    {0xE52BFC7442353B0C, 0x034E26D1E1E608D1},
    {0xB756639034F76270, 0x02A4EBDB1B1E6D74},
    {0x2C451C735D92B526, 0x021D897C15B1F12A},
    {0x13A1C71EFC1DEEA3, 0x0362759355E981DD},
    {0x761B05B2634B2550, 0x02B52ADC44BACE4A},
    {0x91AF37C1E908EAA6, 0x022A88B036FBD83B},
    {0x82B1F2CFDB417770, 0x03774119F192F392},
    {0xCEF4C23FE29AC5F3, 0x02C5CDAE5ADBF60E},
    {0x3F2A34FFE87BD190, 0x0237D7BEAF165E72},
    {0x984387FFDA5FB5B2, 0x038C8C644B56FD83},
    {0xE0360666484C915B, 0x02D6D6B6A2ABFE02},
    {0x802B3851D3707449, 0x024578921BBCCB35},
    {0x99DEC082EBE72075, 0x03A25A835F947855},
    {0xAE4BCD358985B391, 0x02E8486919439377},
    {0xBEA30A913AD15C74, 0x02536D20E102DC5F},
    {0xFDD1AA81F7B560B9, 0x03B8AE9B019E2D65},
    {0x97DAEECE5FC44D61, 0x02FA2548CE182451},
    {0xDFE258A51969D781, 0x0261B76D71ACE9DA},
    {0x996A276E8F0FBF34, 0x03CF8BE24F7B0FC4},
    {0xE121B9253F3FCC2A, 0x030C6FE83F95A636},
    {0xB41AFA8432997022, 0x02705986994484F8},
    {0xECF7F739EA8F19CF, 0x03E6F5A4286DA18D},
    {0x23F99294BBA5AE40, 0x031F2AE9B9F14E0B},
    {0x4FFADBAA2FB7BE99, 0x027F5587C7F43E6F},
    {0x7FF7C5DD1925FDC2, 0x03FEEF3FA6539718},
    {0xCCC637E4141E649B, 0x033258FFB842DF46},
    {0xD704F983434B83AF, 0x028EAD9960357F6B},
    {0x126A6135CF6F9C8C, 0x020BBE144CF79923},
    {0x83DD685618B29414, 0x0345FCED47F28E9E},
    {0x9CB12044E08EDCDD, 0x029E63F1065BA54B},
    {0x16F419D0B3A57D7D, 0x02184FF405161DD6},
    {0x8B20294DEC3BFBFB, 0x035A19866E89C956},
    {0x3C19BAA4BCFCC996, 0x02AE7AD1F207D445},
    {0xC9AE2EEA30CA3ADF, 0x02252F0E5B39769D},
    {0x0F7D17DD1ADD2AFD, 0x036EB1B091F58A96},
    {0x3F97464A7BE42264, 0x02BEF48D41913BAB},
    {0xCC790508631CE850, 0x02325D3DCE0DC955},
    {0xE0C1A1A704FB0D4D, 0x0383C862E3494222},
    {0x4D67B4859D95A43E, 0x02CFD3824F6DCE82},
    {0x711FC39E17AAE9CB, 0x023FDC683F8B0B9B},
    {0xE832D2968C44A945, 0x039960A6CC11AC2B},
    {0xECF575453D03BA9E, 0x02E11A1F09A7BCEF},
    {0x572AC4376402FBB1, 0x024DAE7F3AEC9726},
    {0x58446D256CD192B5, 0x03AF7D985E47583D},
    {0x79D0575123DADBC4, 0x02F2CAE04B6C4697},
    {0x94A6AC40E97BE303, 0x025BD5803C569EDF},
    {0x8771139B0F2C9E6C, 0x03C62266C6F0FE32},
    {0x9F8DA948D8F07EBD, 0x0304E85238C0CB5B},
    {0xE60AEDD3E0C06564, 0x026A5374FA33D5E2},
    {0xA344AFB9679A3BD2, 0x03DD5254C3862304},
    {0xE903BFC78614FCA8, 0x031775109C6B4F36},
    {0xBA6966393810CA20, 0x02792A73B055D8F8},
    {0x2A423D2859B4769A, 0x03F510B91A22F4C1},
    {0xEE9B642047C39215, 0x032A73C7481BF700},
    {0xBEE2B680396941AA, 0x02885C9F6CE32C00},
    {0xFF1BC53361210155, 0x0206B07F8A4F5666},
    {0x31C6085235019BBB, 0x033DE73276E5570B},
    {0x27D1A041C4014963, 0x0297EC285F1DDF3C},
    {0xECA7B367D0010782, 0x021323537F4B18FC},
    {0xADD91F0C8001A59D, 0x0351D21F3211C194},
    {0xF17A7F3D3334847E, 0x02A7DB4C280E3476},
    {0x279532975C2A0398, 0x021FE2A3533E905F},
    {0xD8EEB75893766C26, 0x0366376BB8641A31},
    {0x7A5892AD42C52352, 0x02B82C562D1CE1C1},
    {0xFB7A0EF102374F75, 0x022CF044F0E3E7CD},
    {0xC59017E8038BB254, 0x037B1A07E7D30C7C},
    {0x37A67986693C8EAA, 0x02C8E19FECA8D6CA},
    {0xF951FAD1EDCA0BBB, 0x023A4E198A20ABD4},
    {0x28832AE97C76792B, 0x03907CF5A9CDDFBB},
    {0x2068EF21305EC756, 0x02D9FD9154A4B2FC},
    {0x19ED8C1A8D189F78, 0x0247FE0DDD508F30},
    {0x5CAF4690E1C0FF26, 0x03A66349621A7EB3},
    {0x4A25D20D81673285, 0x02EB82A11B48655C},
    {0x3B5174D79AB8F537, 0x0256021A7C39EAB0},
    {0x921BEE25C45B21F1, 0x03BCD02A605CAAB3},
    {0xDB498B5169E2818E, 0x02FD735519E3BBC2},
    {0x15D46F7454B53472, 0x02645C4414B62FCF},
    {0xEFBA4BED545520B6, 0x03D3C6D35456B2E4},
    {0xF2FB6FF110441A2B, 0x030FD242A9DEF583},
    {0x8F2F8CC0D9D014EF, 0x02730E9BBB18C469},
    {0xB1E5AE015C80217F, 0x03EB4A92C4F46D75},
    {0xC1848B344A001ACC, 0x0322A20F03F6BDF7},
    {0xCE03A2903B3348A3, 0x02821B3F365EFE5F},
    {0xD802E873628F6D4F, 0x0201AF65C518CB7F},
    {0x599E40B89DB2487F, 0x0335E56FA1C14599},
    {0xE14B66FA17C1D399, 0x029184594E3437AD},
    {0x81091F2E7967DC7A, 0x020E037AA4F692F1},
    {0x9B41CB7D8F0C93F6, 0x03499F2AA18A84B5},
    {0xAF67D5FE0C0A0FF8, 0x02A14C221AD536F7},
    {0xF2B977FE70080CC7, 0x021AA34E7BDDC592},
    {0x1DF58CCA4CD9AE0B, 0x035DD2172C9608EB},
    {0xE4C470A1D7148B3C, 0x02B174DF56DE6D88},
    {0x83D05A1B1276D5CA, 0x022790B2ABE5246D},
    {0x9FB3C35E83F1560F, 0x0372811DDFD50715},
    {0xB2F635E5365AAB3F, 0x02C200E4B310D277},
    {0xF591C4B75EAEEF66, 0x0234CD83C273DB92},
    {0xEF4FA125644B18A3, 0x0387AF39371FC5B7},
    {0x8C3FB41DE9D5AD4F, 0x02D2F2942C196AF9},
    {0x3CFFC34B2177BDD9, 0x02425BA9BCE12261},
    {0x94CC6BAB68BF9628, 0x039D5F75FB01D09B},
    {0x10A38955ED6611B9, 0x02E44C5E6267DA16},
    {0xDA1C6DDE5784DAFB, 0x02503D184EB97B44},
    {0xF693E2FD58D49191, 0x03B394F3B128C53A},
    {0xC5431BFDE0AA0E0E, 0x02F610C2F4209DC8},
    {0x6A9C1664B3BB3E72, 0x025E73CF29B3B16D},
    {0x10F9BD6DEC5ECA4F, 0x03CA52E50F85E8AF},
    {0xDA616457F04BD50C, 0x03084250D937ED58},
    {0xE1E783798D09773D, 0x026D01DA475FF113},
    {0x030C058F480F252E, 0x03E19C9072331B53},
    {0x68D66AD906728425, 0x031AE3A6C1C27C42},
    {0x8711EF14052869B7, 0x027BE952349B969B},
    {0x0B4FE4ECD50D75F2, 0x03F97550542C242C},
    {0xA2A650BD773DF7F5, 0x032DF7737689B689},
    {0xB551DA312C31932A, 0x028B2C5C5ED49207},
    {0x5DDB14F4235ADC22, 0x0208F049E576DB39},
    {0x2FC4EE536BC49369, 0x034180763BF15EC2},
    {0xBFD0BEA92303A921, 0x029ACD2B63277F01},
    {0x9973CBBA8269541A, 0x021570EF8285FF34},
    {0x5BEC792A6A42202A, 0x0355817F373CCB87},
    {0xE3239421EE9B4CEF, 0x02AACDFF5F63D605},
    {0xB5B6101B25490A59, 0x02223E65E5E97804},
    {0x22BCE691D541AA27, 0x0369FD6FD64259A1},
    {0xB563EBA7DDCE21B9, 0x02BB31264501E14D},
    {0xF78322ECB171B494, 0x022F5A850401810A},
    {0x259E9E47824F8753, 0x037EF73B399C01AB},
    {0x1E187E9F9B72D2A9, 0x02CBF8FC2E1667BC},
    {0x4B46CBB2E2C24221, 0x023CC73024DEB963},
    {0x120ADF849E039D01, 0x039471E6A1645BD2},
    {0xDB3BE603B19C7D9A, 0x02DD27EBB4504974},
    {0x7C2FEB3627B0647C, 0x024A865629D9D45D},
    {0x2D197856A5E7072C, 0x03AA7089DC8FBA2F},
    {0x8A7AC6ABB7EC05BD, 0x02EEC06E4A0C94F2},
    {0xD52F05562CBCD164, 0x025899F1D4D6DD8E},
    {0x21E4D556ADFAE8A0, 0x03C0F64FBAF1627E},
    {0xE7EA444557FBED4D, 0x0300C50C958DE864},
    {0xECBB69D1132FF10A, 0x0267040A113E5383},
    {0xADF8A94E851981AA, 0x03D8067681FD526C},
    {0x8B2D543ED0E13488, 0x0313385ECE6441F0},
    {0xD5BDDCFF0D80F6D3, 0x0275C6B23EB69B26},
    {0x892FC7FE7C018AEB, 0x03EFA45064575EA4},
    {0x3A8C9FFEC99AD589, 0x03261D0D1D12B21D},
    {0xC8707FFF07AF113B, 0x0284E40A7DA88E7D},
    {0x39F39998D2F2742F, 0x0203E9A1FE2071FE},
    {0x8FEC28F484B7204B, 0x033975CFFD00B663},
    {0xD989BA5D36F8E6A2, 0x02945E3FFD9A2B82},
    {0x47A161E42BFA521C, 0x02104B66647B5602},
    {0x0C35696D132A1CF9, 0x034D4570A0C5566A},
    {0x09C454574288172D, 0x02A4378D4D6AAB88},
    {0xA169DD129BA0128B, 0x021CF93DD7888939},
    {0x0242FB50F9001DAB, 0x03618EC958DA7529},
    {0x9B68C90D940017BC, 0x02B4723AAD7B90ED},
    {0x4920A0D7A999AC96, 0x0229F4FBBDFC73F1},
    {0x750101590F5C4757, 0x037654C5FCC71FE8},
    {0x2A6734473F7D05DF, 0x02C5109E63D27FED},
    {0xEEB8F69F65FD9E4C, 0x0237407EB641FFF0},
    {0xE45B24323CC8FD46, 0x038B9A6456CFFFE7},
    {0xB6AF502830A0CA9F, 0x02D6151D123FFFEC},
    {0xF88C402026E7087F, 0x0244DDB0DB666656},
    {0x2746CD003E3E73FE, 0x03A162B4923D708B},
    {0x1F6BD73364FEC332, 0x02E7822A0E978D3C},
    {0xE5EFDF5C50CBCF5B, 0x0252CE880BAC70FC},
    {0x3CB2FEFA1ADFB22B, 0x03B7B0D9AC471B2E},
    {0x308F3261AF195B56, 0x02F95A47BD05AF58},
    {0x5A0C284E25ADE2AB, 0x0261150630D15913},
    {0x29AD0D49D5E30445, 0x03CE8809E7B55B52},
    {0x548A7107DE4F369D, 0x030BA007EC9115DB},
    {0xDD3B8D9FE50C2BB1, 0x026FB3398A0DAB15},
    {0x952C15CCA1AD12B5, 0x03E5EB8F434911BC},
    {0x775677D6E7BDA891, 0x031E560C35D40E30},
    {0xC5DEC645863153A7, 0x027EAB3CF7DCD826},
};

static constexpr Uint64x2 kPow5Double[kPow5DoubleTableSize] = { // 5216 bytes
    {0x0000000000000000, 0x0100000000000000},
    {0x0000000000000000, 0x0140000000000000},
    {0x0000000000000000, 0x0190000000000000},
    {0x0000000000000000, 0x01F4000000000000},
    {0x0000000000000000, 0x0138800000000000},
    {0x0000000000000000, 0x0186A00000000000},
    {0x0000000000000000, 0x01E8480000000000},
    {0x0000000000000000, 0x01312D0000000000},
    {0x0000000000000000, 0x017D784000000000},
    {0x0000000000000000, 0x01DCD65000000000},
    {0x0000000000000000, 0x012A05F200000000},
    {0x0000000000000000, 0x0174876E80000000},
    {0x0000000000000000, 0x01D1A94A20000000},
    {0x0000000000000000, 0x012309CE54000000},
    {0x0000000000000000, 0x016BCC41E9000000},
    {0x0000000000000000, 0x01C6BF5263400000},
    {0x0000000000000000, 0x011C37937E080000},
    {0x0000000000000000, 0x016345785D8A0000},
    {0x0000000000000000, 0x01BC16D674EC8000},
    {0x0000000000000000, 0x01158E460913D000},
    {0x0000000000000000, 0x015AF1D78B58C400},
    {0x0000000000000000, 0x01B1AE4D6E2EF500},
    {0x0000000000000000, 0x010F0CF064DD5920},
    {0x0000000000000000, 0x0152D02C7E14AF68},
    {0x0000000000000000, 0x01A784379D99DB42},
    {0x4000000000000000, 0x0108B2A2C2802909},
    {0x9000000000000000, 0x014ADF4B7320334B},
    {0x7400000000000000, 0x019D971E4FE8401E},
    {0x0880000000000000, 0x01027E72F1F12813},
    {0xCAA0000000000000, 0x01431E0FAE6D7217},
    {0xBD48000000000000, 0x0193E5939A08CE9D},
    {0x2C9A000000000000, 0x01F8DEF8808B0245},
    {0x3BE0400000000000, 0x013B8B5B5056E16B},
    {0x0AD8500000000000, 0x018A6E32246C99C6},
    {0x8D8E640000000000, 0x01ED09BEAD87C037},
    {0xB878FE8000000000, 0x013426172C74D822},
    {0x66973E2000000000, 0x01812F9CF7920E2B},
    {0x403D0DA800000000, 0x01E17B84357691B6},
    {0xE826288900000000, 0x012CED32A16A1B11},
    {0x622FB2AB40000000, 0x0178287F49C4A1D6},
    {0xFABB9F5610000000, 0x01D6329F1C35CA4B},
    {0x7CB54395CA000000, 0x0125DFA371A19E6F},
    {0x5BE2947B3C800000, 0x016F578C4E0A060B},
    {0x32DB399A0BA00000, 0x01CB2D6F618C878E},
    {0xDFC9040047440000, 0x011EFC659CF7D4B8},
    {0x17BB450059150000, 0x0166BB7F0435C9E7},
    {0xDDAA16406F5A4000, 0x01C06A5EC5433C60},
    {0x8A8A4DE845986800, 0x0118427B3B4A05BC},
    {0xAD2CE16256FE8200, 0x015E531A0A1C872B},
    {0x987819BAECBE2280, 0x01B5E7E08CA3A8F6},
    {0x1F4B1014D3F6D590, 0x0111B0EC57E6499A},
    {0xA71DD41A08F48AF4, 0x01561D276DDFDC00},
    {0xD0E549208B31ADB1, 0x01ABA4714957D300},
    {0x828F4DB456FF0C8E, 0x010B46C6CDD6E3E0},
    {0xA33321216CBECFB2, 0x014E1878814C9CD8},
    {0xCBFFE969C7EE839E, 0x01A19E96A19FC40E},
    {0x3F7FF1E21CF51243, 0x0105031E2503DA89},
    {0x8F5FEE5AA43256D4, 0x014643E5AE44D12B},
    {0x7337E9F14D3EEC89, 0x0197D4DF19D60576},
    {0x1005E46DA08EA7AB, 0x01FDCA16E04B86D4},
    {0x8A03AEC4845928CB, 0x013E9E4E4C2F3444},
    {0xAC849A75A56F72FD, 0x018E45E1DF3B0155},
    {0x17A5C1130ECB4FBD, 0x01F1D75A5709C1AB},
    {0xEEC798ABE93F11D6, 0x013726987666190A},
    {0xAA797ED6E38ED64B, 0x0184F03E93FF9F4D},
    {0x1517DE8C9C728BDE, 0x01E62C4E38FF8721},
    {0xAD2EEB17E1C7976B, 0x012FDBB0E39FB474},
    {0xD87AA5DDDA397D46, 0x017BD29D1C87A191},
    {0x4E994F5550C7DC97, 0x01DAC74463A989F6},
    {0xF11FD195527CE9DE, 0x0128BC8ABE49F639},
    {0x6D67C5FAA71C2456, 0x0172EBAD6DDC73C8},
    {0x88C1B77950E32D6C, 0x01CFA698C95390BA},
    {0x957912ABD28DFC63, 0x0121C81F7DD43A74},
    {0xBAD75756C7317B7C, 0x016A3A275D494911},
    {0x298D2D2C78FDDA5B, 0x01C4C8B1349B9B56},
    {0xD9F83C3BCB9EA879, 0x011AFD6EC0E14115},
    {0x50764B4ABE865297, 0x0161BCCA7119915B},
    {0x2493DE1D6E27E73D, 0x01BA2BFD0D5FF5B2},
    {0x56DC6AD264D8F086, 0x01145B7E285BF98F},
    {0x2C938586FE0F2CA8, 0x0159725DB272F7F3},
    {0xF7B866E8BD92F7D2, 0x01AFCEF51F0FB5EF},
    {0xFAD34051767BDAE3, 0x010DE1593369D1B5},
    {0x79881065D41AD19C, 0x015159AF80444623},
    {0x57EA147F49218603, 0x01A5B01B605557AC},
    {0xB6F24CCF8DB4F3C1, 0x01078E111C3556CB},
    {0xA4AEE003712230B2, 0x014971956342AC7E},
    {0x4DDA98044D6ABCDF, 0x019BCDFABC13579E},
    {0xF0A89F02B062B60B, 0x010160BCB58C16C2},
    {0xACD2C6C35C7B638E, 0x0141B8EBE2EF1C73},
    {0x98077874339A3C71, 0x01922726DBAAE390},
    {0xBE0956914080CB8E, 0x01F6B0F092959C74},
    {0xF6C5D61AC8507F38, 0x013A2E965B9D81C8},
    {0x34774BA17A649F07, 0x0188BA3BF284E23B},
    {0x01951E89D8FDC6C8, 0x01EAE8CAEF261ACA},
    {0x40FD3316279E9C3D, 0x0132D17ED577D0BE},
    {0xD13C7FDBB186434C, 0x017F85DE8AD5C4ED},
    {0x458B9FD29DE7D420, 0x01DF67562D8B3629},
    {0xCB7743E3A2B0E494, 0x012BA095DC7701D9},
    {0x3E5514DC8B5D1DB9, 0x017688BB5394C250},
    {0x4DEA5A13AE346527, 0x01D42AEA2879F2E4},
    {0xB0B2784C4CE0BF38, 0x01249AD2594C37CE},
    {0x5CDF165F6018EF06, 0x016DC186EF9F45C2},
    {0xF416DBF7381F2AC8, 0x01C931E8AB871732},
    {0xD88E497A83137ABD, 0x011DBF316B346E7F},
    {0xCEB1DBD923D8596C, 0x01652EFDC6018A1F},
    {0xC25E52CF6CCE6FC7, 0x01BE7ABD3781ECA7},
    {0xD97AF3C1A40105DC, 0x01170CB642B133E8},
    {0x0FD9B0B20D014754, 0x015CCFE3D35D80E3},
    {0xD3D01CDE90419929, 0x01B403DCC834E11B},
    {0x6462120B1A28FFB9, 0x01108269FD210CB1},
    {0xBD7A968DE0B33FA8, 0x0154A3047C694FDD},
    {0x2CD93C3158E00F92, 0x01A9CBC59B83A3D5},
    {0x3C07C59ED78C09BB, 0x010A1F5B81324665},
    {0x8B09B7068D6F0C2A, 0x014CA732617ED7FE},
    {0x2DCC24C830CACF34, 0x019FD0FEF9DE8DFE},
    {0xDC9F96FD1E7EC180, 0x0103E29F5C2B18BE},
    {0x93C77CBC661E71E1, 0x0144DB473335DEEE},
    {0x38B95BEB7FA60E59, 0x01961219000356AA},
    {0xC6E7B2E65F8F91EF, 0x01FB969F40042C54},
    {0xFC50CFCFFBB9BB35, 0x013D3E2388029BB4},
    {0x3B6503C3FAA82A03, 0x018C8DAC6A0342A2},
    {0xCA3E44B4F9523484, 0x01EFB1178484134A},
    {0xBE66EAF11BD360D2, 0x0135CEAEB2D28C0E},
    {0x6E00A5AD62C83907, 0x0183425A5F872F12},
    {0x0980CF18BB7A4749, 0x01E412F0F768FAD7},
    {0x65F0816F752C6C8D, 0x012E8BD69AA19CC6},
    {0xFF6CA1CB527787B1, 0x017A2ECC414A03F7},
    {0xFF47CA3E2715699D, 0x01D8BA7F519C84F5},
    {0xBF8CDE66D86D6202, 0x0127748F9301D319},
    {0x2F7016008E88BA83, 0x017151B377C247E0},
    {0x3B4C1B80B22AE923, 0x01CDA62055B2D9D8},
    {0x250F91306F5AD1B6, 0x012087D4358FC827},
    {0xEE53757C8B318623, 0x0168A9C942F3BA30},
    {0x29E852DBADFDE7AC, 0x01C2D43B93B0A8BD},
    {0x3A3133C94CBEB0CC, 0x0119C4A53C4E6976},
    {0xC8BD80BB9FEE5CFF, 0x016035CE8B6203D3},
    {0xBAECE0EA87E9F43E, 0x01B843422E3A84C8},
    {0x74D40C9294F238A7, 0x01132A095CE492FD},
    {0xD2090FB73A2EC6D1, 0x0157F48BB41DB7BC},
    {0x068B53A508BA7885, 0x01ADF1AEA12525AC},
    {0x8417144725748B53, 0x010CB70D24B7378B},
    {0x651CD958EED1AE28, 0x014FE4D06DE5056E},
    {0xFE640FAF2A8619B2, 0x01A3DE04895E46C9},
    {0x3EFE89CD7A93D00F, 0x01066AC2D5DAEC3E},
    {0xCEBE2C40D938C413, 0x014805738B51A74D},
    {0x426DB7510F86F518, 0x019A06D06E261121},
    {0xC9849292A9B4592F, 0x0100444244D7CAB4},
    {0xFBE5B73754216F7A, 0x01405552D60DBD61},
    {0x7ADF25052929CB59, 0x01906AA78B912CBA},
    {0x1996EE4673743E2F, 0x01F485516E7577E9},
    {0xAFFE54EC0828A6DD, 0x0138D352E5096AF1},
    {0x1BFDEA270A32D095, 0x018708279E4BC5AE},
    {0xA2FD64B0CCBF84BA, 0x01E8CA3185DEB719},
    {0x05DE5EEE7FF7B2F4, 0x01317E5EF3AB3270},
    {0x0755F6AA1FF59FB1, 0x017DDDF6B095FF0C},
    {0x092B7454A7F3079E, 0x01DD55745CBB7ECF},
    {0x65BB28B4E8F7E4C3, 0x012A5568B9F52F41},
    {0xBF29F2E22335DDF3, 0x0174EAC2E8727B11},
    {0x2EF46F9AAC035570, 0x01D22573A28F19D6},
    {0xDD58C5C0AB821566, 0x0123576845997025},
    {0x54AEF730D6629AC0, 0x016C2D4256FFCC2F},
    {0x29DAB4FD0BFB4170, 0x01C73892ECBFBF3B},
    {0xFA28B11E277D08E6, 0x011C835BD3F7D784},
    {0x38B2DD65B15C4B1F, 0x0163A432C8F5CD66},
    {0xC6DF94BF1DB35DE7, 0x01BC8D3F7B3340BF},
    {0xDC4BBCF772901AB0, 0x0115D847AD000877},
    {0xD35EAC354F34215C, 0x015B4E5998400A95},
    {0x48365742A30129B4, 0x01B221EFFE500D3B},
    {0x0D21F689A5E0BA10, 0x010F5535FEF20845},
    {0x506A742C0F58E894, 0x01532A837EAE8A56},
    {0xE4851137132F22B9, 0x01A7F5245E5A2CEB},
    {0x6ED32AC26BFD75B4, 0x0108F936BAF85C13},
    {0x4A87F57306FCD321, 0x014B378469B67318},
    {0x5D29F2CFC8BC07E9, 0x019E056584240FDE},
    {0xFA3A37C1DD7584F1, 0x0102C35F729689EA},
    {0xB8C8C5B254D2E62E, 0x014374374F3C2C65},
    {0x26FAF71EEA079FB9, 0x01945145230B377F},
    {0xF0B9B4E6A48987A8, 0x01F965966BCE055E},
    {0x5674111026D5F4C9, 0x013BDF7E0360C35B},
    {0x2C111554308B71FB, 0x018AD75D8438F432},
    {0xB7155AA93CAE4E7A, 0x01ED8D34E547313E},
    {0x326D58A9C5ECF10C, 0x013478410F4C7EC7},
    {0xFF08AED437682D4F, 0x01819651531F9E78},
    {0x3ECADA89454238A3, 0x01E1FBE5A7E78617},
    {0x873EC895CB496366, 0x012D3D6F88F0B3CE},
    {0x290E7ABB3E1BBC3F, 0x01788CCB6B2CE0C2},
    {0xB352196A0DA2AB4F, 0x01D6AFFE45F818F2},
    {0xB0134FE24885AB11, 0x01262DFEEBBB0F97},
    {0x9C1823DADAA715D6, 0x016FB97EA6A9D37D},
    {0x031E2CD19150DB4B, 0x01CBA7DE5054485D},
    {0x21F2DC02FAD2890F, 0x011F48EAF234AD3A},
    {0xAA6F9303B9872B53, 0x01671B25AEC1D888},
    {0xD50B77C4A7E8F628, 0x01C0E1EF1A724EAA},
    {0xC5272ADAE8F199D9, 0x01188D357087712A},
    {0x7670F591A32E004F, 0x015EB082CCA94D75},
    {0xD40D32F60BF98063, 0x01B65CA37FD3A0D2},
    {0xC4883FD9C77BF03E, 0x0111F9E62FE44483},
    {0xB5AA4FD0395AEC4D, 0x0156785FBBDD55A4},
    {0xE314E3C447B1A760, 0x01AC1677AAD4AB0D},
    {0xADED0E5AACCF089C, 0x010B8E0ACAC4EAE8},
    {0xD96851F15802CAC3, 0x014E718D7D7625A2},
    {0x8FC2666DAE037D74, 0x01A20DF0DCD3AF0B},
    {0x39D980048CC22E68, 0x010548B68A044D67},
    {0x084FE005AFF2BA03, 0x01469AE42C8560C1},
    {0x4A63D8071BEF6883, 0x0198419D37A6B8F1},
    {0x9CFCCE08E2EB42A4, 0x01FE52048590672D},
    {0x821E00C58DD309A7, 0x013EF342D37A407C},
    {0xA2A580F6F147CC10, 0x018EB0138858D09B},
    {0x8B4EE134AD99BF15, 0x01F25C186A6F04C2},
    {0x97114CC0EC80176D, 0x0137798F428562F9},
    {0xFCD59FF127A01D48, 0x018557F31326BBB7},
    {0xFC0B07ED7188249A, 0x01E6ADEFD7F06AA5},
    {0xBD86E4F466F516E0, 0x01302CB5E6F642A7},
    {0xACE89E3180B25C98, 0x017C37E360B3D351},
    {0x1822C5BDE0DEF3BE, 0x01DB45DC38E0C826},
    {0xCF15BB96AC8B5857, 0x01290BA9A38C7D17},
    {0xC2DB2A7C57AE2E6D, 0x01734E940C6F9C5D},
    {0x3391F51B6D99BA08, 0x01D022390F8B8375},
    {0x403B393124801445, 0x01221563A9B73229},
    {0x904A077D6DA01956, 0x016A9ABC9424FEB3},
    {0x745C895CC9081FAC, 0x01C5416BB92E3E60},
    {0x48B9D5D9FDA513CB, 0x011B48E353BCE6FC},
    {0x5AE84B507D0E58BE, 0x01621B1C28AC20BB},
    {0x31A25E249C51EEEE, 0x01BAA1E332D728EA},
    {0x5F057AD6E1B33554, 0x0114A52DFFC67992},
    {0xF6C6D98C9A2002AA, 0x0159CE797FB817F6},
    {0xB4788FEFC0A80354, 0x01B04217DFA61DF4},
    {0xF0CB59F5D8690214, 0x010E294EEBC7D2B8},
    {0x2CFE30734E83429A, 0x0151B3A2A6B9C767},
    {0xF83DBC9022241340, 0x01A6208B50683940},
    {0x9B2695DA15568C08, 0x0107D457124123C8},
    {0xC1F03B509AAC2F0A, 0x0149C96CD6D16CBA},
    {0x726C4A24C1573ACD, 0x019C3BC80C85C7E9},
    {0xE783AE56F8D684C0, 0x0101A55D07D39CF1},
    {0x616499ECB70C25F0, 0x01420EB449C8842E},
    {0xF9BDC067E4CF2F6C, 0x019292615C3AA539},
    {0x782D3081DE02FB47, 0x01F736F9B3494E88},
    {0x4B1C3E512AC1DD0C, 0x013A825C100DD115},
    {0x9DE34DE57572544F, 0x018922F31411455A},
    {0x455C215ED2CEE963, 0x01EB6BAFD91596B1},
    {0xCB5994DB43C151DE, 0x0133234DE7AD7E2E},
    {0x7E2FFA1214B1A655, 0x017FEC216198DDBA},
    {0x1DBBF89699DE0FEB, 0x01DFE729B9FF1529},
    {0xB2957B5E202AC9F3, 0x012BF07A143F6D39},
    {0x1F3ADA35A8357C6F, 0x0176EC98994F4888},
    {0x270990C31242DB8B, 0x01D4A7BEBFA31AAA},
    {0x5865FA79EB69C937, 0x0124E8D737C5F0AA},
    {0xEE7F791866443B85, 0x016E230D05B76CD4},
    {0x2A1F575E7FD54A66, 0x01C9ABD04725480A},
    {0x5A53969B0FE54E80, 0x011E0B622C774D06},
    {0xF0E87C41D3DEA220, 0x01658E3AB7952047},
    {0xED229B5248D64AA8, 0x01BEF1C9657A6859},
    {0x3435A1136D85EEA9, 0x0117571DDF6C8138},
    {0x4143095848E76A53, 0x015D2CE55747A186},
    {0xD193CBAE5B2144E8, 0x01B4781EAD1989E7},
    {0xE2FC5F4CF8F4CB11, 0x0110CB132C2FF630},
    {0x1BBB77203731FDD5, 0x0154FDD7F73BF3BD},
    {0x62AA54E844FE7D4A, 0x01AA3D4DF50AF0AC},
    {0xBDAA75112B1F0E4E, 0x010A6650B926D66B},
    {0xAD15125575E6D1E2, 0x014CFFE4E7708C06},
    {0x585A56EAD360865B, 0x01A03FDE214CAF08},
    {0x37387652C41C53F8, 0x010427EAD4CFED65},
    {0x850693E7752368F7, 0x014531E58A03E8BE},
    {0x264838E1526C4334, 0x01967E5EEC84E2EE},
    {0xAFDA4719A7075402, 0x01FC1DF6A7A61BA9},
    {0x0DE86C7008649481, 0x013D92BA28C7D14A},
    {0x9162878C0A7DB9A1, 0x018CF768B2F9C59C},
    {0xB5BB296F0D1D280A, 0x01F03542DFB83703},
    {0x5194F9E568323906, 0x01362149CBD32262},
    {0xE5FA385EC23EC747, 0x0183A99C3EC7EAFA},
    {0x9F78C67672CE7919, 0x01E494034E79E5B9},
    {0x03AB7C0A07C10BB0, 0x012EDC82110C2F94},
    {0x04965B0C89B14E9C, 0x017A93A2954F3B79},
    {0x45BBF1CFAC1DA243, 0x01D9388B3AA30A57},
    {0x8B957721CB92856A, 0x0127C35704A5E676},
    {0x2E7AD4EA3E7726C4, 0x0171B42CC5CF6014},
    {0x3A198A24CE14F075, 0x01CE2137F7433819},
    {0xC44FF65700CD1649, 0x0120D4C2FA8A030F},
    {0xB563F3ECC1005BDB, 0x016909F3B92C83D3},
    {0xA2BCF0E7F14072D2, 0x01C34C70A777A4C8},
    {0x65B61690F6C847C3, 0x011A0FC668AAC6FD},
    {0xBF239C35347A59B4, 0x016093B802D578BC},
    {0xEEEC83428198F021, 0x01B8B8A6038AD6EB},
    {0x7553D20990FF9615, 0x01137367C236C653},
    {0x52A8C68BF53F7B9A, 0x01585041B2C477E8},
    {0x6752F82EF28F5A81, 0x01AE64521F7595E2},
    {0x8093DB1D57999890, 0x010CFEB353A97DAD},
    {0xE0B8D1E4AD7FFEB4, 0x01503E602893DD18},
    {0x18E7065DD8DFFE62, 0x01A44DF832B8D45F},
    {0x6F9063FAA78BFEFD, 0x0106B0BB1FB384BB},
    {0x4B747CF9516EFEBC, 0x01485CE9E7A065EA},
    {0xDE519C37A5CABE6B, 0x019A742461887F64},
    {0x0AF301A2C79EB703, 0x01008896BCF54F9F},
    {0xCDAFC20B798664C4, 0x0140AABC6C32A386},
    {0x811BB28E57E7FDF5, 0x0190D56B873F4C68},
    {0xA1629F31EDE1FD72, 0x01F50AC6690F1F82},
    {0xA4DDA37F34AD3E67, 0x013926BC01A973B1},
    {0x0E150C5F01D88E01, 0x0187706B0213D09E},
    {0x919A4F76C24EB181, 0x01E94C85C298C4C5},
    {0x7B0071AA39712EF1, 0x0131CFD3999F7AFB},
    {0x59C08E14C7CD7AAD, 0x017E43C8800759BA},
    {0xF030B199F9C0D958, 0x01DDD4BAA0093028},
    {0x961E6F003C1887D7, 0x012AA4F4A405BE19},
    {0xFBA60AC04B1EA9CD, 0x01754E31CD072D9F},
    {0xFA8F8D705DE65440, 0x01D2A1BE4048F907},
    {0xFC99B8663AAFF4A8, 0x0123A516E82D9BA4},
    {0x3BC0267FC95BF1D2, 0x016C8E5CA239028E},
    {0xCAB0301FBBB2EE47, 0x01C7B1F3CAC74331},
    {0x1EAE1E13D54FD4EC, 0x011CCF385EBC89FF},
    {0xE659A598CAA3CA27, 0x01640306766BAC7E},
    {0x9FF00EFEFD4CBCB1, 0x01BD03C81406979E},
    {0x23F6095F5E4FF5EF, 0x0116225D0C841EC3},
    {0xECF38BB735E3F36A, 0x015BAAF44FA52673},
    {0xE8306EA5035CF045, 0x01B295B1638E7010},
    {0x911E4527221A162B, 0x010F9D8EDE39060A},
    {0x3565D670EAA09BB6, 0x015384F295C7478D},
    {0x82BF4C0D2548C2A3, 0x01A8662F3B391970},
    {0x51B78F88374D79A6, 0x01093FDD8503AFE6},
    {0xE625736A4520D810, 0x014B8FD4E6449BDF},
    {0xDFAED044D6690E14, 0x019E73CA1FD5C2D7},
    {0xEBCD422B0601A8CC, 0x0103085E53E599C6},
    {0xA6C092B5C78212FF, 0x0143CA75E8DF0038},
    {0xD070B763396297BF, 0x0194BD136316C046},
    {0x848CE53C07BB3DAF, 0x01F9EC583BDC7058},
    {0x52D80F4584D5068D, 0x013C33B72569C637},
    {0x278E1316E60A4831, 0x018B40A4EEC437C5},
};

inline Uint64x2 Mul128(uint64_t a, uint64_t b)
{
#if CC_HAS_UINT128
    __extension__ using uint128_t = unsigned __int128;

    uint128_t const product = uint128_t{a} * b;

    uint64_t const lo = static_cast<uint64_t>(product);
    uint64_t const hi = static_cast<uint64_t>(product >> 64);

    return {lo, hi};
#elif CC_HAS_64_BIT_INTRINSICS
    uint64_t hi;
    uint64_t lo = _umul128(a, b, &hi);
    return {lo, hi};
#else
    uint32_t const aLo = static_cast<uint32_t>(a);
    uint32_t const aHi = static_cast<uint32_t>(a >> 32);
    uint32_t const bLo = static_cast<uint32_t>(b);
    uint32_t const bHi = static_cast<uint32_t>(b >> 32);

    uint64_t const b00 = uint64_t{aLo} * bLo;
    uint64_t const b01 = uint64_t{aLo} * bHi;
    uint64_t const b10 = uint64_t{aHi} * bLo;
    uint64_t const b11 = uint64_t{aHi} * bHi;

    uint32_t const b00Lo = static_cast<uint32_t>(b00);
    uint32_t const b00Hi = static_cast<uint32_t>(b00 >> 32);

    uint64_t const mid1 = b10 + b00Hi;
    uint32_t const mid1Lo = static_cast<uint32_t>(mid1);
    uint32_t const mid1Hi = static_cast<uint32_t>(mid1 >> 32);

    uint64_t const mid2 = b01 + mid1Lo;
    uint32_t const mid2Lo = static_cast<uint32_t>(mid2);
    uint32_t const mid2Hi = static_cast<uint32_t>(mid2 >> 32);

    uint64_t const hi = b11 + mid1Hi + mid2Hi;
    uint64_t const lo = (uint64_t{mid2Lo} << 32) + b00Lo;
    return {lo, hi};
#endif
}

inline uint64_t ShiftRight128(Uint64x2 x, int dist)
{
    // For the __shiftright128 intrinsic, the shift value is always modulo 64.
    // In the current implementation of the double-precision version of Ryu, the
    // shift value is always < 64.
    // The shift value actually is in the range [49, 58].
    // Check this here in case a future change requires larger shift values. In
    // this case this function needs to be adjusted.
    CC_ASSERT(dist >= 49);
    CC_ASSERT(dist <= 58);
    unsigned char const amt = static_cast<unsigned char>(dist);

#if 0 && CC_HAS_UINT128
    __extension__ using uint128_t = unsigned __int128;
    return static_cast<uint64_t>(((uint128_t{x.hi} << 64) | x.lo) >> (amt/* % 64*/));
#elif CC_HAS_64_BIT_INTRINSICS
    return __shiftright128(x.lo, x.hi, amt);
#else
#if CC_32_BIT_PLATFORM
    // Avoid a 64-bit shift by taking advantage of the range of shift values.
    return (x.hi << (64 - amt)) | (static_cast<uint32_t>(x.lo >> 32) >> (amt - 32));
#else
    return (x.hi << (64 - amt)) | (x.lo >> amt);
#endif
#endif
}

// We need a 64x128 bit multiplication and a subsequent 128-bit shift.
// Multiplication:
//   The 64-bit factor is variable and passed in, the 128-bit factor comes
//   from a lookup table. We know that the 64-bit factor only has 55
//   significant bits (i.e., the 9 topmost bits are zeros). The 128-bit
//   factor only has 124 significant bits (i.e., the 4 topmost bits are
//   zeros).
// Shift:
//   In principle, the multiplication result requires 55+124=179 bits to
//   represent. However, we then shift this value to the right by j, which is
//   at least j >= 115, so the result is guaranteed to fit into 179-115=64
//   bits. This means that we only need the topmost 64 significant bits of
//   the 64x128-bit multiplication.
//
// There are several ways to do this:
// 1. Best case: the compiler exposes a 128-bit type
//    We perform two 64x64-bit multiplications, add the higher 64 bits of the
//    lower result to the higher result, and shift by j-64 bits.
//
//    We explicitly cast from 64-bit to 128-bit, so the compiler can tell
//    that these are only 64-bit inputs, and can map these to the best
//    possible sequence of assembly instructions.
//    x86-64 machines happen to have matching assembly instructions for
//    64x64-bit multiplications and 128-bit shifts.
//
// 2. Second best case: the compiler exposes intrinsics for the x86-64 assembly
//    instructions mentioned in 1.
//
// 3. We only have 64x64 bit instructions that return the lower 64 bits of
//    the result, i.e., we have to use plain C.
//    Our inputs are less than the full width, so we have three options:
//    a. Ignore this fact and just implement the intrinsics manually
//    b. Split both into 31-bit pieces, which guarantees no internal overflow,
//       but requires extra work upfront (unless we change the lookup table).
//    c. Split only the first factor into 31-bit pieces, which also guarantees
//       no internal overflow, but requires extra work since the intermediate
//       results are not perfectly aligned.

inline uint64_t MulShift(uint64_t m, Uint64x2 const* mul, int j)
{
    CC_ASSERT((m >> 55) == 0); // m is maximum 55 bits

#if 1 && CC_HAS_UINT128
    __extension__ using uint128_t = unsigned __int128;

    uint128_t const b0 = uint128_t{m} * mul->lo;
    uint128_t const b2 = uint128_t{m} * mul->hi;

    return static_cast<uint64_t>(((b0 >> 64) + b2) >> (j - 64));
#else
    auto b0 = Mul128(m, mul->lo);
    auto b2 = Mul128(m, mul->hi);

    b2.lo += b0.hi;
    b2.hi += (b2.lo < b0.hi);

    return ShiftRight128(b2, j - 64);
#endif
}

#if 1 && (CC_HAS_UINT128 || CC_HAS_64_BIT_INTRINSICS)
inline void MulShiftAll(uint64_t mv, uint64_t mp, uint64_t mm, Uint64x2 const* mul, int j, uint64_t* vr, uint64_t* vp, uint64_t* vm)
{
    CC_ASSERT((mv >> 55) == 0); // m2 is maximum 55 bits

    *vr = MulShift(mv, mul, j);
    *vp = MulShift(mp, mul, j);
    *vm = MulShift(mm, mul, j);
}
#else
inline void MulShiftAll(uint64_t mv, uint64_t /*mp*/, uint64_t mm, Uint64x2 const* mul, int j, uint64_t* vr, uint64_t* vp, uint64_t* vm)
{
    CC_ASSERT((mv >> 55) == 0); // m2 is maximum 55 bits

    uint64_t const m2 = mv / 2;
    uint32_t const mmShift = static_cast<uint32_t>(mv - mm - 1);

    auto const b0 = Mul128(m2, mul->lo);
    auto const b2 = Mul128(m2, mul->hi);

    uint64_t const lo  = b0.lo;
    uint64_t const mid = b2.lo + b0.hi;
    uint64_t const hi  = b2.hi + (mid < b0.hi);
    *vr = ShiftRight128({mid, hi}, j - 64 - 1);

    uint64_t const lo2  = lo + mul->lo;
    uint64_t const mid2 = mid + mul->hi + (lo2 < lo);
    uint64_t const hi2  = hi + (mid2 < mid);
    *vp = ShiftRight128({mid2, hi2}, j - 64 - 1);

    if (mmShift == 1) {
        uint64_t const lo3  = lo - mul->lo;
        uint64_t const mid3 = mid - mul->hi - (lo3 > lo);
        uint64_t const hi3  = hi - (mid3 > mid);
        *vm = ShiftRight128({mid3, hi3}, j - 64 - 1);
    } else {
        uint64_t const lo3  = lo + lo;
        uint64_t const mid3 = mid + mid + (lo3 < lo);
        uint64_t const hi3  = hi + hi + (mid3 < mid);
        uint64_t const lo4  = lo3 - mul->lo;
        uint64_t const mid4 = mid3 - mul->hi - (lo4 > lo3);
        uint64_t const hi4  = hi3 - (mid4 > mid3);
        *vm = ShiftRight128({mid4, hi4}, j - 64);
    }
}
#endif

#if CC_32_BIT_PLATFORM

// On x86 platforms, compilers typically generate calls to library
// functions for 64-bit divisions, even if the divisor is a constant.
//
// E.g.:
// https://bugs.llvm.org/show_bug.cgi?id=37932
// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=17958
// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=37443
//
// The functions here perform division-by-constant using multiplications
// in the same way as 64-bit compilers would do.
//
// NB:
// The multipliers and shift values are the ones generated by clang x64
// for expressions like x/5, x/10, etc.

inline uint64_t Div5(const uint64_t x)
{
    return Mul128(x, 0xCCCCCCCCCCCCCCCDu).hi >> 2;
}

inline uint64_t Div10(const uint64_t x)
{
    return Mul128(x, 0xCCCCCCCCCCCCCCCDu).hi >> 3;
}

inline uint64_t Div100(const uint64_t x)
{
    return Mul128(x >> 2, 0x28F5C28F5C28F5C3u).hi >> 2;
}

inline uint64_t Div100000000(const uint64_t x)
{
    return Mul128(x, 0xABCC77118461CEFDu).hi >> 26;
}

#endif // CC_32_BIT_PLATFORM

inline int ComputeQForNonNegativeExponent(int e)
{
    return Log10Pow2(e) - (e > 3);
}

inline int ComputeQForNegativeExponent(int e)
{
    return Log10Pow5(e) - (e > 1);
}

inline int Pow5Factor(uint64_t value)
{
    // For 64-bit integers: result <= 27
    // Since value here has at most 55-bits: result <= 23

    int factor = 0;
    for (;;) {
        CC_ASSERT(value != 0);
        CC_ASSERT(factor <= 23);

#if CC_32_BIT_PLATFORM
        uint64_t const q = Div5(value);
        uint32_t const r = static_cast<uint32_t>(value - 5 * q);
        if (r != 0)
            return factor;
        value = q;
#else
        if (value % 5 != 0) {
            return factor;
        }
        value /= 5;
#endif
        ++factor;
    }
}

inline bool MultipleOfPow5(uint64_t value, int p)
{
    return Pow5Factor(value) >= p;
}

inline bool MultipleOfPow2(uint64_t value, int p)
{
    CC_ASSERT(p >= 0);
    CC_ASSERT(p <= 63);

    return (value & ((uint64_t{1} << p) - 1)) == 0;
//  return (value << (64 - p)) == 0;
}

inline int DecimalLengthDouble(uint64_t v)
{
    CC_ASSERT(v < 100000000000000000ull);

    if (v >= 10000000000000000ull) { return 17; }
    if (v >= 1000000000000000ull) { return 16; }
    if (v >= 100000000000000ull) { return 15; }
    if (v >= 10000000000000ull) { return 14; }
    if (v >= 1000000000000ull) { return 13; }
    if (v >= 100000000000ull) { return 12; }
    if (v >= 10000000000ull) { return 11; }
    if (v >= 1000000000ull) { return 10; }
    if (v >= 100000000ull) { return 9; }
    if (v >= 10000000ull) { return 8; }
    if (v >= 1000000ull) { return 7; }
    if (v >= 100000ull) { return 6; }
    if (v >= 10000ull) { return 5; }
    if (v >= 1000ull) { return 4; }
    if (v >= 100ull) { return 3; }
    if (v >= 10ull) { return 2; }
    return 1;
}

inline int PrintDecimalDigitsDouble(char* buf, uint64_t output)
{
    int const output_length = DecimalLengthDouble(output);
    int i = output_length;

    // We prefer 32-bit operations, even on 64-bit platforms.
    // We have at most 17 digits, and uint32_t can store 9 digits.
    // If output doesn't fit into uint32_t, we cut off 8 digits,
    // so the rest will fit into uint32_t.
    if (static_cast<uint32_t>(output >> 32) != 0)
    {
        CC_ASSERT(i > 8);
#if CC_32_BIT_PLATFORM
        uint64_t const q = Div100000000(output);
        uint32_t const r = static_cast<uint32_t>(output - 100000000 * q);
#else
        uint64_t const q = output / 100000000;
        uint32_t const r = static_cast<uint32_t>(output % 100000000);
#endif
        output = q;
        i -= 8;
        Utoa_8Digits(buf + i, r);
    }

    CC_ASSERT(output <= UINT32_MAX);
    uint32_t output2 = static_cast<uint32_t>(output);

    while (output2 >= 10000)
    {
        CC_ASSERT(i > 4);
        uint32_t const r = output2 % 10000;
        output2 /= 10000;
        i -= 4;
        Utoa_4Digits(buf + i, r);
    }

    if (output2 >= 100)
    {
        CC_ASSERT(i > 2);
        uint32_t const r = output2 % 100;
        output2 /= 100;
        i -= 2;
        Utoa_2Digits(buf + i, r);
    }

    if (output2 >= 10)
    {
        CC_ASSERT(i == 2);
        Utoa_2Digits(buf, output2);
    }
    else
    {
        CC_ASSERT(i == 1);
        buf[0] = static_cast<char>('0' + output2);
    }

    return output_length;
}

struct DoubleToDecimalResult {
    uint64_t digits;
    int exponent;
};

inline DoubleToDecimalResult DoubleToDecimal(double value)
{
    CC_ASSERT(Double(value).IsFinite());
    CC_ASSERT(value > 0);

    //
    // Step 1:
    // Decode the floating point number, and unify normalized and subnormal cases.
    //

    Double const ieee_value(value);

    // Decode bits into mantissa, and exponent.
    uint64_t const ieeeMantissa = ieee_value.PhysicalSignificand();
    uint64_t const ieeeExponent = ieee_value.PhysicalExponent();

    uint64_t m2;
    int e2;
    if (ieeeExponent == 0) {
        m2 = ieeeMantissa;
        e2 = 1;
    } else {
        m2 = Double::HiddenBit | ieeeMantissa;
        e2 = static_cast<int>(ieeeExponent);
    }

    bool const even = (m2 & 1) == 0;
    bool const acceptBounds = even;

    //
    // Step 2:
    // Determine the interval of legal decimal representations.
    //

    // We subtract 2 so that the bounds computation has 2 additional bits.
    e2 -= Double::ExponentBias + 2;

    uint64_t const mv = 4 * m2;
    uint64_t const mp = mv + 2;
    uint32_t const mmShift = (ieeeMantissa != 0 || ieeeExponent <= 1) ? 1 : 0;
    uint64_t const mm = mv - 1 - mmShift;

    //
    // Step 3:
    // Convert to a decimal power base using 128-bit arithmetic.
    //

    int e10;

    uint64_t vm;
    uint64_t vr;
    uint64_t vp;

    bool vmIsTrailingZeros = false;
    bool vrIsTrailingZeros = false;
    bool vpIsTrailingZeros = false;

    if (e2 >= 0)
    {
        // I tried special-casing q == 0, but there was no effect on performance.
        int const q = ComputeQForNonNegativeExponent(e2);
        CC_ASSERT(q >= 0);
        int const k = kPow5InvDoubleBitLength + Pow5BitLength(q) - 1;
        int const j = -e2 + q + k;
        CC_ASSERT(j >= 114 + (q == 0 ? 1 : 0));

        e10 = q;

        CC_ASSERT(q < kPow5InvDoubleTableSize);
        MulShiftAll(mv, mp, mm, kPow5InvDouble + q, j, &vr, &vp, &vm);

        if (q <= 22) // 22 = floor(log_5(2^53))
//      if (q <= 23) // 23 = floor(log_5(2^(53+2)))
        {
            // This should use q <= 22, but I think 21 is also safe. Smaller values
            // may still be safe, but it's more difficult to reason about them.
            // Only one of mp, mv, and mm can be a multiple of 5, if any.
#if CC_32_BIT_PLATFORM
            if (mv - 5 * Div5(mv) == 0)
#else
            if (mv % 5 == 0)
#endif
            {
                vrIsTrailingZeros = MultipleOfPow5(mv, q);
            }
            else if (acceptBounds)
            {
                // Same as min(e2 + (~mm & 1), Pow5Factor(mm)) >= q
                // <=> e2 + (~mm & 1) >= q && Pow5Factor(mm) >= q
                // <=> true && Pow5Factor(mm) >= q, since e2 >= q.
                vmIsTrailingZeros = MultipleOfPow5(mm, q);
            }
            else
            {
                // Same as min(e2 + 1, Pow5Factor(mp)) >= q.
                vpIsTrailingZeros = MultipleOfPow5(mp, q);
            }
        }
    }
    else
    {
        int const q = ComputeQForNegativeExponent(-e2);
        CC_ASSERT(q >= 0);
        int const i = -e2 - q;
        int const k = Pow5BitLength(i) - kPow5DoubleBitLength;
        int const j = q - k;
        CC_ASSERT(j >= 114);

        e10 = e2 + q;

        CC_ASSERT(i < kPow5DoubleTableSize);
        MulShiftAll(mv, mp, mm, kPow5Double + i, j, &vr, &vp, &vm);

        if (q <= 1)
        {
            // {vr,vp,vm} is trailing zeros if {mv,mp,mm} has at least q trailing 0 bits.
            // mv = 4 * m2, so it always has at least two trailing 0 bits.
            vrIsTrailingZeros = true;

            if (acceptBounds)
            {
                // mm = mv - 1 - mmShift, so it has 1 trailing 0 bit iff mmShift == 1.
                vmIsTrailingZeros = (mmShift == 1);
            }
            else
            {
                // mp = mv + 2, so it always has at least one trailing 0 bit.
                vpIsTrailingZeros = true;
            }
        }
//      else if (q <= 64)
        else if (q <= Double::SignificandSize + 2)
        {
            // TODO(ulfjack): Use a tighter bound here.

            // We need to compute min(ntz(mv), Pow5Factor(mv) - e2) >= q-1
            // <=> ntz(mv) >= q-1  &&  Pow5Factor(mv) - e2 >= q-1
            // <=> ntz(mv) >= q-1
            // <=> mv & ((1 << (q-1)) - 1) == 0
            // We also need to make sure that the left shift does not overflow.
            CC_ASSERT(q >= 1);
            vrIsTrailingZeros = MultipleOfPow2(mv, q - 1);
        }
    }

    //
    // Step 4:
    // Find the shortest decimal representation in the interval of legal representations.
    //

    // On average, we remove ~2 digits.

    vp -= vpIsTrailingZeros;

    uint64_t output;

    if (vmIsTrailingZeros || vrIsTrailingZeros)
    {
        // General case, which happens rarely (<1%).

        uint32_t lastRemovedDigit = 0;

#if CC_DTOA_ROUND_TO_NEAREST_EVEN
        bool vrPrevIsTrailingZeros = vrIsTrailingZeros;
#endif

#if CC_32_BIT_PLATFORM
        for (;;)
        {
            uint64_t const vmDiv10 = Div10(vm);
            uint64_t const vpDiv10 = Div10(vp);
            if (vmDiv10 >= vpDiv10)
                break;

            uint32_t const vmMod10 = static_cast<uint32_t>(vm - 10 * vmDiv10);
            vmIsTrailingZeros &= vmMod10 == 0;
#if CC_DTOA_ROUND_TO_NEAREST_EVEN
            vrPrevIsTrailingZeros &= lastRemovedDigit == 0;
#endif

            uint64_t const vrDiv10 = Div10(vr);
            uint32_t const vrMod10 = static_cast<uint32_t>(vr - 10 * vrDiv10);
            lastRemovedDigit = vrMod10;

            vm = vmDiv10;
            vr = vrDiv10;
            vp = vpDiv10;
            ++e10;
        }

        if (vmIsTrailingZeros)
        {
            for (;;)
            {
                uint64_t const vmDiv10 = Div10(vm);
                uint32_t const vmMod10 = static_cast<uint32_t>(vm - 10 * vmDiv10);
                if (vmMod10 != 0)
                    break;

#if CC_DTOA_ROUND_TO_NEAREST_EVEN
                vrPrevIsTrailingZeros &= lastRemovedDigit == 0;
#endif

                uint64_t const vrDiv10 = Div10(vr);
                uint32_t const vrMod10 = static_cast<uint32_t>(vr - 10 * vrDiv10);
                lastRemovedDigit = vrMod10;

                vm = vmDiv10;
                vr = vrDiv10;
                //vp = Div10(vp);
                ++e10;
            }
        }
#else // ^^^ CC_32_BIT_PLATFORM
        while (vm / 10 < vp / 10)
        {
            vmIsTrailingZeros &= vm % 10 == 0;
#if CC_DTOA_ROUND_TO_NEAREST_EVEN
            vrPrevIsTrailingZeros &= lastRemovedDigit == 0;
#endif

            lastRemovedDigit = static_cast<uint32_t>(vr % 10);

            vm /= 10;
            vr /= 10;
            vp /= 10;
            ++e10;
        }

        if (vmIsTrailingZeros)
        {
            while (vm % 10 == 0)
            {
#if CC_DTOA_ROUND_TO_NEAREST_EVEN
                vrPrevIsTrailingZeros &= lastRemovedDigit == 0;
#endif

                lastRemovedDigit = static_cast<uint32_t>(vr % 10);

                vm /= 10;
                vr /= 10;
                //vp /= 10;
                ++e10;
            }
        }
#endif // ^^^ !CC_32_BIT_PLATFORM

        bool roundUp = lastRemovedDigit >= 5;
#if CC_DTOA_ROUND_TO_NEAREST_EVEN
        if (lastRemovedDigit == 5 && vrPrevIsTrailingZeros)
        {
            // Halfway case: The number ends in ...500...00.
            roundUp = static_cast<uint32_t>(vr) % 2 != 0;
        }
#endif

        // We need to take vr+1 if vr is outside bounds...
        // or we need to round up.
        bool const inc = (vr == vm && !(acceptBounds && vmIsTrailingZeros)) || roundUp;

        output = vr + (inc ? 1 : 0);
    }
    else
    {
        // Specialized for the common case (>99%).

        bool roundUp = false;

#if CC_32_BIT_PLATFORM
        uint64_t const vmDiv100 = Div100(vm);
        uint64_t const vpDiv100 = Div100(vp);
        if (vmDiv100 < vpDiv100)
        {
            uint64_t const vrDiv100 = Div100(vr);
            uint32_t const vrMod100 = static_cast<uint32_t>(vr - 100 * vrDiv100);
            roundUp = vrMod100 >= 50;

            vm = vmDiv100;
            vr = vrDiv100;
            vp = vpDiv100;
            e10 += 2;
        }

        for (;;)
        {
            uint64_t const vmDiv10 = Div10(vm);
            uint64_t const vpDiv10 = Div10(vp);
            if (vmDiv10 >= vpDiv10)
                break;

            uint64_t const vrDiv10 = Div10(vr);
            uint32_t const vrMod10 = static_cast<uint32_t>(vr - 10 * vrDiv10);
            roundUp = vrMod10 >= 5;

            vm = vmDiv10;
            vr = vrDiv10;
            vp = vpDiv10;
            ++e10;
        }
#else
        //if (vm / 100 < vp / 100)
        //{
        //    roundUp = static_cast<uint32_t>(vr % 100) >= 50;
        //
        //    vm /= 100;
        //    vr /= 100;
        //    vp /= 100;
        //    e10 += 2;
        //}

        while (vm / 10 < vp / 10)
        {
            roundUp = static_cast<uint32_t>(vr % 10) >= 5;

            vm /= 10;
            vr /= 10;
            vp /= 10;
            ++e10;
        }
#endif

        // We need to take vr+1 if vr is outside bounds...
        // or we need to round up.
        bool const inc = vr == vm || roundUp;

        output = vr + (inc ? 1 : 0);
    }

    //
    // Step 5:
    // Print the decimal representation.
    //

    return {output, e10};
}

//==================================================================================================
// Dtoa
//==================================================================================================

inline void DoubleToDigits(char* buffer, int& num_digits, int& exponent, double value)
{
    CC_ASSERT(Double(value).IsFinite());
    CC_ASSERT(value > 0);

    DoubleToDecimalResult res = DoubleToDecimal(value);

    num_digits = PrintDecimalDigitsDouble(buffer, res.digits);
    exponent = res.exponent;
}

inline char* ExponentToString(char* buffer, int value)
{
    CC_ASSERT(value > -1000);
    CC_ASSERT(value <  1000);

    int n = 0;

    if (value < 0)
    {
        buffer[n++] = '-';
        value = -value;
    }
    else
    {
        buffer[n++] = '+';
    }

    uint32_t const k = static_cast<uint32_t>(value);
    if (k < 10)
    {
        buffer[n++] = static_cast<char>('0' + k);
    }
    else if (k < 100)
    {
        Utoa_2Digits(buffer + n, k);
        n += 2;
    }
    else
    {
        uint32_t const r = k % 10;
        uint32_t const q = k / 10;
        Utoa_2Digits(buffer + n, q);
        n += 2;
        buffer[n++] = static_cast<char>('0' + r);
    }

    return buffer + n;
}

inline char* FormatFixed(char* buffer, int length, int decimal_point, bool force_trailing_dot_zero)
{
    CC_ASSERT(buffer != nullptr);
    CC_ASSERT(length >= 1);

    if (length <= decimal_point)
    {
        // digits[000]
        // CC_ASSERT(buffer_capacity >= decimal_point + (force_trailing_dot_zero ? 2 : 0));

        std::memset(buffer + length, '0', static_cast<size_t>(decimal_point - length));
        buffer += decimal_point;
        if (force_trailing_dot_zero)
        {
            *buffer++ = '.';
            *buffer++ = '0';
        }
        return buffer;
    }
    else if (0 < decimal_point)
    {
        // dig.its
        // CC_ASSERT(buffer_capacity >= length + 1);

        std::memmove(buffer + (decimal_point + 1), buffer + decimal_point, static_cast<size_t>(length - decimal_point));
        buffer[decimal_point] = '.';
        return buffer + (length + 1);
    }
    else // decimal_point <= 0
    {
        // 0.[000]digits
        // CC_ASSERT(buffer_capacity >= 2 + (-decimal_point) + length);

        std::memmove(buffer + (2 + -decimal_point), buffer, static_cast<size_t>(length));
        buffer[0] = '0';
        buffer[1] = '.';
        std::memset(buffer + 2, '0', static_cast<size_t>(-decimal_point));
        return buffer + (2 + (-decimal_point) + length);
    }
}

inline char* FormatExponential(char* buffer, int length, int exponent)
{
    CC_ASSERT(buffer != nullptr);
    CC_ASSERT(length >= 1);

    if (length == 1)
    {
        // dE+123
        // CC_ASSERT(buffer_capacity >= length + 5);

        //
        // XXX:
        // Should force_trailing_dot_zero apply here?!?!
        //

        buffer += 1;
    }
    else
    {
        // d.igitsE+123
        // CC_ASSERT(buffer_capacity >= length + 1 + 5);

        std::memmove(buffer + 2, buffer + 1, static_cast<size_t>(length - 1));
        buffer[1] = '.';
        buffer += 1 + length;
    }

//  if (exponent != 0)
    {
        buffer[0] = 'e';
        buffer = ExponentToString(buffer + 1, exponent);
    }

    return buffer;
}

inline char* FormatGeneral(char* buffer, int num_digits, int exponent, bool force_trailing_dot_zero)
{
    int const decimal_point = num_digits + exponent;

#if 0

#if 1
    buffer[num_digits] = 'e';
    return ExponentToString(buffer + (num_digits + 1), decimal_point - 1);
#else
    return FormatExponential(buffer, num_digits, decimal_point - 1);
#endif

#else

    // Changing these constants requires changing kDtoaMaxLength (see below) too.
    // XXX:
    // Compute kDtoaMaxLength using these constants...?!
#if 0
    constexpr int const kMinExp = -4;
    constexpr int const kMaxExp = 17; // std::numeric_limits<Fp>::max_digits10;
#else
    constexpr int const kMinExp = -6;
    constexpr int const kMaxExp = 21;
#endif

    bool const use_fixed = kMinExp < decimal_point && decimal_point <= kMaxExp;

    return use_fixed
        ? FormatFixed(buffer, num_digits, decimal_point, force_trailing_dot_zero)
        : FormatExponential(buffer, num_digits, decimal_point - 1);

#endif
}

inline char* PositiveDoubleToString(char* buffer, double value, bool force_trailing_dot_zero = false)
{
    CC_ASSERT(Double(value).IsFinite());
    CC_ASSERT(value > 0);

    int num_digits = 0;
    int exponent = 0;
    DoubleToDigits(buffer, num_digits, exponent, value);

    CC_ASSERT(num_digits <= std::numeric_limits<double>::max_digits10);

    return FormatGeneral(buffer, num_digits, exponent, force_trailing_dot_zero);
}

//==================================================================================================
// DigitsToIEEE
//
// Derived from the double-conversion library:
// https://github.com/google/double-conversion
//
// The original license can be found below.
//
// [1] Clinger, "How to read floating point numbers accurately",
//     PLDI '90 Proceedings of the ACM SIGPLAN 1990 conference on Programming
//     language design and implementation, Pages 92-101
//==================================================================================================

/*
Copyright 2006-2011, the V8 project authors. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.
    * Neither the name of Google Inc. nor the names of its
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// Maximum number of significant digits in decimal representation.
//
// The longest possible double in decimal representation is (2^53 - 1) * 5^1074 / 10^1074,
// which has 767 digits.
// If we parse a number whose first digits are equal to a mean of 2 adjacent
// doubles (that could have up to 768 digits) the result must be rounded to the
// bigger one unless the tail consists of zeros, so we don't need to preserve
// all the digits.
constexpr int kMaxSignificantDigits = 767 + 1;

inline constexpr int Min(int x, int y) { return y < x ? y : x; }
inline constexpr int Max(int x, int y) { return y < x ? x : y; }

inline bool IsDigit(char ch)
{
#if 0
    return static_cast<unsigned>(ch - '0') < 10;
#else
    return '0' <= ch && ch <= '9';
#endif
}

inline int DigitValue(char ch)
{
    CC_ASSERT(IsDigit(ch));
    return ch - '0';
}

//--------------------------------------------------------------------------------------------------
// StrtodFast
//--------------------------------------------------------------------------------------------------

// Double operations detection based on target architecture.
// Linux uses a 80bit wide floating point stack on x86. This induces double
// rounding, which in turn leads to wrong results.
// An easy way to test if the floating-point operations are correct is to
// evaluate: 89255.0/1e22.
// If the floating-point stack is 64 bits wide then the result is equal to
// 89255e-22. The best way to test this, is to create a division-function and to
// compare the output of the division with the expected result. (Inlining must
// be disabled.)
#if !defined(STRTOD_CORRECT_DOUBLE_OPERATIONS)
#if defined(_M_X64)              || \
    defined(_M_ARM)				 || \
    defined(_M_ARM64)			 || \
    defined(__x86_64__)          || \
    defined(__ARMEL__)           || \
    defined(__avr32__)           || \
    defined(__hppa__)            || \
    defined(__ia64__)            || \
    defined(__mips__)            || \
    defined(__powerpc__)         || \
    defined(__ppc__)             || \
    defined(__ppc64__)           || \
    defined(_POWER)              || \
    defined(_ARCH_PPC)           || \
    defined(_ARCH_PPC64)         || \
    defined(__sparc__)           || \
    defined(__sparc)             || \
    defined(__s390__)            || \
    defined(__SH4__)             || \
    defined(__alpha__)           || \
    defined(_MIPS_ARCH_MIPS32R2) || \
    defined(__AARCH64EL__)       || \
    defined(__aarch64__)         || \
    defined(__riscv)
#define STRTOD_CORRECT_DOUBLE_OPERATIONS 1
#elif defined(_M_IX86) || defined(__i386__) || defined(__i386)
#ifdef _WIN32
// Windows uses a 64bit wide floating point stack.
#define STRTOD_CORRECT_DOUBLE_OPERATIONS 1
#endif
#endif
#endif // !defined(STRTOD_CORRECT_DOUBLE_OPERATIONS)

#if STRTOD_CORRECT_DOUBLE_OPERATIONS

// 2^53 = 9007199254740992.
// Any integer with at most 15 decimal digits will hence fit into a double
// (which has a 53-bit significand) without loss of precision.
constexpr int kMaxExactDoubleIntegerDecimalDigits = 15;

inline bool FastPath(double& result, uint64_t digits, int num_digits, int exponent)
{
    static constexpr int kMaxExactPowerOfTen = 22;
    static constexpr double kExactPowersOfTen[] = {
        1.0e+00,
        1.0e+01,
        1.0e+02,
        1.0e+03,
        1.0e+04,
        1.0e+05,
        1.0e+06,
        1.0e+07,
        1.0e+08,
        1.0e+09,
        1.0e+10,
        1.0e+11,
        1.0e+12,
        1.0e+13,
        1.0e+14,
        1.0e+15, // 10^15 < 9007199254740992 = 2^53
        1.0e+16, // 10^16 = 5000000000000000 * 2^1  = (10^15 * 5^1 ) * 2^1
        1.0e+17, // 10^17 = 6250000000000000 * 2^4  = (10^13 * 5^4 ) * 2^4
        1.0e+18, // 10^18 = 7812500000000000 * 2^7  = (10^11 * 5^7 ) * 2^7
        1.0e+19, // 10^19 = 4882812500000000 * 2^11 = (10^8  * 5^11) * 2^11
        1.0e+20, // 10^20 = 6103515625000000 * 2^14 = (10^6  * 5^14) * 2^14
        1.0e+21, // 10^21 = 7629394531250000 * 2^17 = (10^4  * 5^17) * 2^17
        1.0e+22, // 10^22 = 4768371582031250 * 2^21 = (10^1  * 5^21) * 2^21
//      1.0e+23,
    };

    if (num_digits > kMaxExactDoubleIntegerDecimalDigits)
        return false;

    // The significand fits into a double.
    // If 10^exponent (resp. 10^-exponent) fits into a double too then we can
    // compute the result simply by multiplying (resp. dividing) the two
    // numbers.
    // This is possible because IEEE guarantees that floating-point operations
    // return the best possible approximation.

    int const remaining_digits = kMaxExactDoubleIntegerDecimalDigits - num_digits; // 0 <= rd <= 15
    if (-kMaxExactPowerOfTen <= exponent && exponent <= remaining_digits + kMaxExactPowerOfTen)
    {
        CC_ASSERT(digits <= INT64_MAX);
        double d = static_cast<double>(static_cast<int64_t>(digits));
        if (exponent < 0)
        {
            d /= kExactPowersOfTen[-exponent];
        }
        else if (exponent <= kMaxExactPowerOfTen)
        {
            d *= kExactPowersOfTen[exponent];
        }
        else
        {
            // The buffer is short and we can multiply it with 10^remaining_digits
            // and the remaining exponent fits into a double.
            //
            // Eg. 123 * 10^25 = (123*1000) * 10^22

            d *= kExactPowersOfTen[remaining_digits]; // exact
            d *= kExactPowersOfTen[exponent - remaining_digits];
        }
        result = d;
        return true;
    }

    return false;
}

#else // ^^^ STRTOD_CORRECT_DOUBLE_OPERATIONS

inline bool FastPath(double& /*result*/, uint64_t /*digits*/, int /*num_digits*/, int /*exponent*/)
{
    return false;
}

#endif // ^^^ !STRTOD_CORRECT_DOUBLE_OPERATIONS

//--------------------------------------------------------------------------------------------------
// StrtodApprox
//--------------------------------------------------------------------------------------------------

struct DiyFp // f * 2^e
{
    static constexpr int SignificandSize = 64; // = q

    uint64_t f = 0;
    int e = 0;

    constexpr DiyFp() = default;
    constexpr DiyFp(uint64_t f_, int e_) : f(f_), e(e_) {}
};

// Returns whether the given floating point value is normalized.
inline bool IsNormalized(DiyFp x)
{
    static_assert(DiyFp::SignificandSize == 64, "internal error");

    return x.f >= (uint64_t{1} << 63);
}

// Returns x - y.
// PRE: x.e == y.e and x.f >= y.f
inline DiyFp Subtract(DiyFp x, DiyFp y)
{
    CC_ASSERT(x.e == y.e);
    CC_ASSERT(x.f >= y.f);

    return DiyFp(x.f - y.f, x.e);
}

// Returns x * y.
// The result is rounded (ties up). (Only the upper q bits are returned.)
inline DiyFp Multiply(DiyFp x, DiyFp y)
{
    static_assert(DiyFp::SignificandSize == 64, "internal error");

    // Computes:
    //  f = round((x.f * y.f) / 2^q)
    //  e = x.e + y.e + q

#if defined(_MSC_VER) && defined(_M_X64)

    uint64_t h = 0;
    uint64_t l = _umul128(x.f, y.f, &h);
    h += l >> 63; // round, ties up: [h, l] += 2^q / 2

    return DiyFp(h, x.e + y.e + 64);

#elif defined(__GNUC__) && defined(__SIZEOF_INT128__)

    __extension__ using Uint128 = unsigned __int128;

    Uint128 const p = Uint128{x.f} * y.f + (uint64_t{1} << 63);
    return DiyFp(static_cast<uint64_t>(p >> 64), x.e + y.e + 64);

#else

    // Emulate the 64-bit * 64-bit multiplication:
    //
    // p = u * v
    //   = (u_lo + 2^32 u_hi) (v_lo + 2^32 v_hi)
    //   = (u_lo v_lo         ) + 2^32 ((u_lo v_hi         ) + (u_hi v_lo         )) + 2^64 (u_hi v_hi         )
    //   = (p0                ) + 2^32 ((p1                ) + (p2                )) + 2^64 (p3                )
    //   = (p0_lo + 2^32 p0_hi) + 2^32 ((p1_lo + 2^32 p1_hi) + (p2_lo + 2^32 p2_hi)) + 2^64 (p3                )
    //   = (p0_lo             ) + 2^32 (p0_hi + p1_lo + p2_lo                      ) + 2^64 (p1_hi + p2_hi + p3)
    //   = (p0_lo             ) + 2^32 (Q                                          ) + 2^64 (H                 )
    //   = (p0_lo             ) + 2^32 (Q_lo + 2^32 Q_hi                           ) + 2^64 (H                 )
    //
    // (Since Q might be larger than 2^32 - 1)
    //
    //   = (p0_lo + 2^32 Q_lo) + 2^64 (Q_hi + H)
    //
    // (Q_hi + H does not overflow a 64-bit int)
    //
    //   = p_lo + 2^64 p_hi

    // Note:
    // The 32/64-bit casts here help MSVC to avoid calls to the _allmul
    // library function.

    uint32_t const u_lo = static_cast<uint32_t>(x.f /*& 0xFFFFFFFF*/);
    uint32_t const u_hi = static_cast<uint32_t>(x.f >> 32);
    uint32_t const v_lo = static_cast<uint32_t>(y.f /*& 0xFFFFFFFF*/);
    uint32_t const v_hi = static_cast<uint32_t>(y.f >> 32);

    uint64_t const p0 = uint64_t{u_lo} * v_lo;
    uint64_t const p1 = uint64_t{u_lo} * v_hi;
    uint64_t const p2 = uint64_t{u_hi} * v_lo;
    uint64_t const p3 = uint64_t{u_hi} * v_hi;

    uint64_t const p0_hi = p0 >> 32;
    uint64_t const p1_lo = p1 & 0xFFFFFFFF;
    uint64_t const p1_hi = p1 >> 32;
    uint64_t const p2_lo = p2 & 0xFFFFFFFF;
    uint64_t const p2_hi = p2 >> 32;

    uint64_t Q = p0_hi + p1_lo + p2_lo;

    // The full product might now be computed as
    //
    // p_hi = p3 + p2_hi + p1_hi + (Q >> 32)
    // p_lo = p0_lo + (Q << 32)
    //
    // But in this particular case here, the full p_lo is not required.
    // Effectively we only need to add the highest bit in p_lo to p_hi (and
    // Q_hi + 1 does not overflow).

    Q += uint32_t{1} << (63 - 32); // round, ties up

    uint64_t const h = p3 + p2_hi + p1_hi + (Q >> 32);

    return DiyFp(h, x.e + y.e + 64);

#endif
}

// Decomposes `value` into `f * 2^e`.
// The result is not normalized.
// PRE: `value` must be finite and non-negative, i.e. >= +0.0.
inline DiyFp DiyFpFromFloat(double value)
{
    auto const v = Double(value);

    CC_ASSERT(v.IsFinite());
    CC_ASSERT(!v.SignBit());

    auto const F = v.PhysicalSignificand();
    auto const E = v.PhysicalExponent();

    // If v is denormal:
    //      value = 0.F * 2^(1 - bias) = (          F) * 2^(1 - bias - (p-1))
    // If v is normalized:
    //      value = 1.F * 2^(E - bias) = (2^(p-1) + F) * 2^(E - bias - (p-1))

    return (E == 0) // denormal?
        ? DiyFp(F, Double::MinExponent)
        : DiyFp(F + Double::HiddenBit, static_cast<int>(E) - Double::ExponentBias);
}

// Compute the boundaries m- and m+ of the floating-point value
// v = f * 2^e.
//
// Determine v- and v+, the floating-point predecessor and successor if v,
// respectively.
//
//      v- = v - 2^e        if f != 2^(p-1) or e == e_min                (A)
//         = v - 2^(e-1)    if f == 2^(p-1) and e > e_min                (B)
//
//      v+ = v + 2^e
//
// Let m- = (v- + v) / 2 and m+ = (v + v+) / 2. All real numbers _strictly_
// between m- and m+ round to v, regardless of how the input rounding
// algorithm breaks ties.
//
//      ---+-------------+-------------+-------------+-------------+---  (A)
//         v-            m-            v             m+            v+
//
//      -----------------+------+------+-------------+-------------+---  (B)
//                       v-     m-     v             m+            v+

// Returns the upper boundary of value, i.e. the upper bound of the rounding
// interval for v.
// The result is not normalized.
// PRE: `value` must be finite and non-negative.
inline DiyFp UpperBoundary(double value)
{
    auto const v = DiyFpFromFloat(value);
//  return DiyFp(2*v.f + 1, v.e - 1);
    return DiyFp(4*v.f + 2, v.e - 2);
}

struct DiyFpWithError // value = (x.f + delta) * 2^x.e, where |delta| <= error
{
    // We don't want to deal with fractions and therefore work with a common
    // denominator.
    static constexpr int DenominatorLog = 1;
    static constexpr int Denominator = 1 << DenominatorLog;

    DiyFp x;
    uint32_t error = 0;

    constexpr DiyFpWithError() = default;
    constexpr DiyFpWithError(DiyFp x_, uint32_t error_) : x(x_), error(error_) {}
};

// Returns the number of leading 0-bits in x, starting at the most significant
// bit position.
// If x is 0, the result is undefined.
inline int CountLeadingZeros64(uint64_t x)
{
    CC_ASSERT(x != 0);

#if defined(_MSC_VER) && (defined(_M_ARM) || defined(_M_ARM64))

    return static_cast<int>(_CountLeadingZeros64(x));

#elif defined(_MSC_VER) && defined(_M_X64)

    return static_cast<int>(__lzcnt64(x));

#elif defined(_MSC_VER) && defined(_M_IX86)

    int lz = static_cast<int>( __lzcnt(static_cast<uint32_t>(x >> 32)) );
    if (lz == 32) {
        lz += static_cast<int>( __lzcnt(static_cast<uint32_t>(x)) );
    }
    return lz;

#elif defined(__GNUC__)

    return __builtin_clzll(x);

#else

    int lz = 0;
    while ((x >> 63) == 0) {
        x <<= 1;
        ++lz;
    }
    return lz;

#endif
}

// Normalize x
// and scale the error, so that the error is in ULP(x)
inline void Normalize(DiyFpWithError& num)
{
    int const s = CountLeadingZeros64(num.x.f);

    CC_ASSERT(((num.error << s) >> s) == num.error);

    num.x.f   <<= s;
    num.x.e    -= s;
    num.error <<= s;
}

template <typename T>
inline T ReadInt(char const* str, int len)
{
    CC_ASSERT(len <= std::numeric_limits<T>::digits10);

    T value = 0;

    for (int i = 0; i < len; ++i)
    {
        value = static_cast<unsigned char>(str[i] - '0') + 10 * value;
    }

    return value;
}

struct CachedPower { // c = f * 2^e ~= 10^k
    uint64_t f;
    int e; // binary exponent
    int k; // decimal exponent
};

// Returns the binary exponent of a cached power for a given decimal exponent.
inline int BinaryExponentFromDecimalExponent(int k)
{
    CC_ASSERT(k <=  400);
    CC_ASSERT(k >= -400);

    // log_2(10) ~= [3; 3, 9, 2, 2, 4, 6, 2, 1, 1, 3] = 254370/76573
    // 2^15 * 254370/76573 = 108852.93980907...

//  return (k * 108853) / (1 << 15) - (k < 0) - 63;
    return (k * 108853 - 63 * (1 << 15)) >> 15;
}

constexpr int kCachedPowersSize         =  673;
constexpr int kCachedPowersMinDecExp    = -348;
constexpr int kCachedPowersMaxDecExp    =  324;
constexpr int kCachedPowersDecExpStep   =    1;

static constexpr uint64_t kCachedPowersSignificands[kCachedPowersSize] = { // 5384 bytes
    0xFA8FD5A0081C0288, // * 2^-1220 <  10^-348
    0x9C99E58405118195, // * 2^-1216 <  10^-347
    0xC3C05EE50655E1FA, // * 2^-1213 <  10^-346
    0xF4B0769E47EB5A79, // * 2^-1210 >  10^-345
    0x98EE4A22ECF3188C, // * 2^-1206 >  10^-344
    0xBF29DCABA82FDEAE, // * 2^-1203 <  10^-343
    0xEEF453D6923BD65A, // * 2^-1200 <  10^-342
    0x9558B4661B6565F8, // * 2^-1196 <  10^-341
    0xBAAEE17FA23EBF76, // * 2^-1193 <  10^-340
    0xE95A99DF8ACE6F54, // * 2^-1190 >  10^-339
    0x91D8A02BB6C10594, // * 2^-1186 <  10^-338
    0xB64EC836A47146FA, // * 2^-1183 >  10^-337
    0xE3E27A444D8D98B8, // * 2^-1180 >  10^-336
    0x8E6D8C6AB0787F73, // * 2^-1176 >  10^-335
    0xB208EF855C969F50, // * 2^-1173 >  10^-334
    0xDE8B2B66B3BC4724, // * 2^-1170 >  10^-333
    0x8B16FB203055AC76, // * 2^-1166 <  10^-332
    0xADDCB9E83C6B1794, // * 2^-1163 >  10^-331
    0xD953E8624B85DD79, // * 2^-1160 >  10^-330
    0x87D4713D6F33AA6C, // * 2^-1156 >  10^-329
    0xA9C98D8CCB009506, // * 2^-1153 <  10^-328
    0xD43BF0EFFDC0BA48, // * 2^-1150 <  10^-327
    0x84A57695FE98746D, // * 2^-1146 <  10^-326
    0xA5CED43B7E3E9188, // * 2^-1143 <  10^-325
    0xCF42894A5DCE35EA, // * 2^-1140 <  10^-324
    0x818995CE7AA0E1B2, // * 2^-1136 <  10^-323
    0xA1EBFB4219491A1F, // * 2^-1133 <  10^-322
    0xCA66FA129F9B60A7, // * 2^-1130 >  10^-321
    0xFD00B897478238D1, // * 2^-1127 >  10^-320
    0x9E20735E8CB16382, // * 2^-1123 <  10^-319
    0xC5A890362FDDBC63, // * 2^-1120 >  10^-318
    0xF712B443BBD52B7C, // * 2^-1117 >  10^-317
    0x9A6BB0AA55653B2D, // * 2^-1113 <  10^-316
    0xC1069CD4EABE89F9, // * 2^-1110 >  10^-315
    0xF148440A256E2C77, // * 2^-1107 >  10^-314
    0x96CD2A865764DBCA, // * 2^-1103 <  10^-313
    0xBC807527ED3E12BD, // * 2^-1100 >  10^-312
    0xEBA09271E88D976C, // * 2^-1097 >  10^-311
    0x93445B8731587EA3, // * 2^-1093 <  10^-310
    0xB8157268FDAE9E4C, // * 2^-1090 <  10^-309
    0xE61ACF033D1A45DF, // * 2^-1087 <  10^-308
    0x8FD0C16206306BAC, // * 2^-1083 >  10^-307
    0xB3C4F1BA87BC8697, // * 2^-1080 >  10^-306
    0xE0B62E2929ABA83C, // * 2^-1077 <  10^-305
    0x8C71DCD9BA0B4926, // * 2^-1073 >  10^-304
    0xAF8E5410288E1B6F, // * 2^-1070 <  10^-303
    0xDB71E91432B1A24B, // * 2^-1067 >  10^-302
    0x892731AC9FAF056F, // * 2^-1063 >  10^-301
    0xAB70FE17C79AC6CA, // * 2^-1060 <  10^-300
    0xD64D3D9DB981787D, // * 2^-1057 <  10^-299
    0x85F0468293F0EB4E, // * 2^-1053 <  10^-298
    0xA76C582338ED2622, // * 2^-1050 >  10^-297
    0xD1476E2C07286FAA, // * 2^-1047 <  10^-296
    0x82CCA4DB847945CA, // * 2^-1043 <  10^-295
    0xA37FCE126597973D, // * 2^-1040 >  10^-294
    0xCC5FC196FEFD7D0C, // * 2^-1037 <  10^-293
    0xFF77B1FCBEBCDC4F, // * 2^-1034 <  10^-292
    0x9FAACF3DF73609B1, // * 2^-1030 <  10^-291
    0xC795830D75038C1E, // * 2^-1027 >  10^-290
    0xF97AE3D0D2446F25, // * 2^-1024 <  10^-289
    0x9BECCE62836AC577, // * 2^-1020 <  10^-288
    0xC2E801FB244576D5, // * 2^-1017 <  10^-287
    0xF3A20279ED56D48A, // * 2^-1014 <  10^-286
    0x9845418C345644D7, // * 2^-1010 >  10^-285
    0xBE5691EF416BD60C, // * 2^-1007 <  10^-284
    0xEDEC366B11C6CB8F, // * 2^-1004 <  10^-283
    0x94B3A202EB1C3F39, // * 2^-1000 <  10^-282
    0xB9E08A83A5E34F08, // * 2^-997  >  10^-281
    0xE858AD248F5C22CA, // * 2^-994  >  10^-280
    0x91376C36D99995BE, // * 2^-990  <  10^-279
    0xB58547448FFFFB2E, // * 2^-987  >  10^-278
    0xE2E69915B3FFF9F9, // * 2^-984  <  10^-277
    0x8DD01FAD907FFC3C, // * 2^-980  >  10^-276
    0xB1442798F49FFB4B, // * 2^-977  >  10^-275
    0xDD95317F31C7FA1D, // * 2^-974  <  10^-274
    0x8A7D3EEF7F1CFC52, // * 2^-970  <  10^-273
    0xAD1C8EAB5EE43B67, // * 2^-967  >  10^-272
    0xD863B256369D4A41, // * 2^-964  >  10^-271
    0x873E4F75E2224E68, // * 2^-960  <  10^-270
    0xA90DE3535AAAE202, // * 2^-957  <  10^-269
    0xD3515C2831559A83, // * 2^-954  <  10^-268
    0x8412D9991ED58092, // * 2^-950  >  10^-267
    0xA5178FFF668AE0B6, // * 2^-947  <  10^-266
    0xCE5D73FF402D98E4, // * 2^-944  >  10^-265
    0x80FA687F881C7F8E, // * 2^-940  <  10^-264
    0xA139029F6A239F72, // * 2^-937  <  10^-263
    0xC987434744AC874F, // * 2^-934  >  10^-262
    0xFBE9141915D7A922, // * 2^-931  <  10^-261
    0x9D71AC8FADA6C9B5, // * 2^-927  <  10^-260
    0xC4CE17B399107C23, // * 2^-924  >  10^-259
    0xF6019DA07F549B2B, // * 2^-921  <  10^-258
    0x99C102844F94E0FB, // * 2^-917  <  10^-257
    0xC0314325637A193A, // * 2^-914  >  10^-256
    0xF03D93EEBC589F88, // * 2^-911  <  10^-255
    0x96267C7535B763B5, // * 2^-907  <  10^-254
    0xBBB01B9283253CA3, // * 2^-904  >  10^-253
    0xEA9C227723EE8BCB, // * 2^-901  <  10^-252
    0x92A1958A7675175F, // * 2^-897  <  10^-251
    0xB749FAED14125D37, // * 2^-894  >  10^-250
    0xE51C79A85916F485, // * 2^-891  >  10^-249
    0x8F31CC0937AE58D3, // * 2^-887  >  10^-248
    0xB2FE3F0B8599EF08, // * 2^-884  >  10^-247
    0xDFBDCECE67006AC9, // * 2^-881  <  10^-246
    0x8BD6A141006042BE, // * 2^-877  >  10^-245
    0xAECC49914078536D, // * 2^-874  <  10^-244
    0xDA7F5BF590966849, // * 2^-871  >  10^-243
    0x888F99797A5E012D, // * 2^-867  <  10^-242
    0xAAB37FD7D8F58179, // * 2^-864  >  10^-241
    0xD5605FCDCF32E1D7, // * 2^-861  >  10^-240
    0x855C3BE0A17FCD26, // * 2^-857  <  10^-239
    0xA6B34AD8C9DFC070, // * 2^-854  >  10^-238
    0xD0601D8EFC57B08C, // * 2^-851  >  10^-237
    0x823C12795DB6CE57, // * 2^-847  <  10^-236
    0xA2CB1717B52481ED, // * 2^-844  <  10^-235
    0xCB7DDCDDA26DA269, // * 2^-841  >  10^-234
    0xFE5D54150B090B03, // * 2^-838  >  10^-233
    0x9EFA548D26E5A6E2, // * 2^-834  >  10^-232
    0xC6B8E9B0709F109A, // * 2^-831  <  10^-231
    0xF867241C8CC6D4C1, // * 2^-828  >  10^-230
    0x9B407691D7FC44F8, // * 2^-824  <  10^-229
    0xC21094364DFB5637, // * 2^-821  >  10^-228
    0xF294B943E17A2BC4, // * 2^-818  <  10^-227
    0x979CF3CA6CEC5B5B, // * 2^-814  >  10^-226
    0xBD8430BD08277231, // * 2^-811  <  10^-225
    0xECE53CEC4A314EBE, // * 2^-808  >  10^-224
    0x940F4613AE5ED137, // * 2^-804  >  10^-223
    0xB913179899F68584, // * 2^-801  <  10^-222
    0xE757DD7EC07426E5, // * 2^-798  <  10^-221
    0x9096EA6F3848984F, // * 2^-794  <  10^-220
    0xB4BCA50B065ABE63, // * 2^-791  <  10^-219
    0xE1EBCE4DC7F16DFC, // * 2^-788  >  10^-218
    0x8D3360F09CF6E4BD, // * 2^-784  <  10^-217
    0xB080392CC4349DED, // * 2^-781  >  10^-216
    0xDCA04777F541C568, // * 2^-778  >  10^-215
    0x89E42CAAF9491B61, // * 2^-774  >  10^-214
    0xAC5D37D5B79B6239, // * 2^-771  <  10^-213
    0xD77485CB25823AC7, // * 2^-768  <  10^-212
    0x86A8D39EF77164BD, // * 2^-764  >  10^-211
    0xA8530886B54DBDEC, // * 2^-761  >  10^-210
    0xD267CAA862A12D67, // * 2^-758  >  10^-209
    0x8380DEA93DA4BC60, // * 2^-754  <  10^-208
    0xA46116538D0DEB78, // * 2^-751  <  10^-207
    0xCD795BE870516656, // * 2^-748  <  10^-206
    0x806BD9714632DFF6, // * 2^-744  <  10^-205
    0xA086CFCD97BF97F4, // * 2^-741  >  10^-204
    0xC8A883C0FDAF7DF0, // * 2^-738  <  10^-203
    0xFAD2A4B13D1B5D6C, // * 2^-735  <  10^-202
    0x9CC3A6EEC6311A64, // * 2^-731  >  10^-201
    0xC3F490AA77BD60FD, // * 2^-728  >  10^-200
    0xF4F1B4D515ACB93C, // * 2^-725  >  10^-199
    0x991711052D8BF3C5, // * 2^-721  <  10^-198
    0xBF5CD54678EEF0B7, // * 2^-718  >  10^-197
    0xEF340A98172AACE5, // * 2^-715  >  10^-196
    0x9580869F0E7AAC0F, // * 2^-711  >  10^-195
    0xBAE0A846D2195713, // * 2^-708  >  10^-194
    0xE998D258869FACD7, // * 2^-705  <  10^-193
    0x91FF83775423CC06, // * 2^-701  <  10^-192
    0xB67F6455292CBF08, // * 2^-698  <  10^-191
    0xE41F3D6A7377EECA, // * 2^-695  <  10^-190
    0x8E938662882AF53E, // * 2^-691  <  10^-189
    0xB23867FB2A35B28E, // * 2^-688  >  10^-188
    0xDEC681F9F4C31F31, // * 2^-685  <  10^-187
    0x8B3C113C38F9F37F, // * 2^-681  >  10^-186
    0xAE0B158B4738705F, // * 2^-678  >  10^-185
    0xD98DDAEE19068C76, // * 2^-675  <  10^-184
    0x87F8A8D4CFA417CA, // * 2^-671  >  10^-183
    0xA9F6D30A038D1DBC, // * 2^-668  <  10^-182
    0xD47487CC8470652B, // * 2^-665  <  10^-181
    0x84C8D4DFD2C63F3B, // * 2^-661  <  10^-180
    0xA5FB0A17C777CF0A, // * 2^-658  >  10^-179
    0xCF79CC9DB955C2CC, // * 2^-655  <  10^-178
    0x81AC1FE293D599C0, // * 2^-651  >  10^-177
    0xA21727DB38CB0030, // * 2^-648  >  10^-176
    0xCA9CF1D206FDC03C, // * 2^-645  >  10^-175
    0xFD442E4688BD304B, // * 2^-642  >  10^-174
    0x9E4A9CEC15763E2F, // * 2^-638  >  10^-173
    0xC5DD44271AD3CDBA, // * 2^-635  <  10^-172
    0xF7549530E188C129, // * 2^-632  >  10^-171
    0x9A94DD3E8CF578BA, // * 2^-628  >  10^-170
    0xC13A148E3032D6E8, // * 2^-625  >  10^-169
    0xF18899B1BC3F8CA2, // * 2^-622  >  10^-168
    0x96F5600F15A7B7E5, // * 2^-618  <  10^-167
    0xBCB2B812DB11A5DE, // * 2^-615  <  10^-166
    0xEBDF661791D60F56, // * 2^-612  <  10^-165
    0x936B9FCEBB25C996, // * 2^-608  >  10^-164
    0xB84687C269EF3BFB, // * 2^-605  <  10^-163
    0xE65829B3046B0AFA, // * 2^-602  <  10^-162
    0x8FF71A0FE2C2E6DC, // * 2^-598  <  10^-161
    0xB3F4E093DB73A093, // * 2^-595  <  10^-160
    0xE0F218B8D25088B8, // * 2^-592  <  10^-159
    0x8C974F7383725573, // * 2^-588  <  10^-158
    0xAFBD2350644EEAD0, // * 2^-585  >  10^-157
    0xDBAC6C247D62A584, // * 2^-582  >  10^-156
    0x894BC396CE5DA772, // * 2^-578  <  10^-155
    0xAB9EB47C81F5114F, // * 2^-575  <  10^-154
    0xD686619BA27255A3, // * 2^-572  >  10^-153
    0x8613FD0145877586, // * 2^-568  >  10^-152
    0xA798FC4196E952E7, // * 2^-565  <  10^-151
    0xD17F3B51FCA3A7A1, // * 2^-562  >  10^-150
    0x82EF85133DE648C5, // * 2^-558  >  10^-149
    0xA3AB66580D5FDAF6, // * 2^-555  >  10^-148
    0xCC963FEE10B7D1B3, // * 2^-552  <  10^-147
    0xFFBBCFE994E5C620, // * 2^-549  >  10^-146
    0x9FD561F1FD0F9BD4, // * 2^-545  >  10^-145
    0xC7CABA6E7C5382C9, // * 2^-542  >  10^-144
    0xF9BD690A1B68637B, // * 2^-539  <  10^-143
    0x9C1661A651213E2D, // * 2^-535  <  10^-142
    0xC31BFA0FE5698DB8, // * 2^-532  <  10^-141
    0xF3E2F893DEC3F126, // * 2^-529  <  10^-140
    0x986DDB5C6B3A76B8, // * 2^-525  >  10^-139
    0xBE89523386091466, // * 2^-522  >  10^-138
    0xEE2BA6C0678B597F, // * 2^-519  <  10^-137
    0x94DB483840B717F0, // * 2^-515  >  10^-136
    0xBA121A4650E4DDEC, // * 2^-512  >  10^-135
    0xE896A0D7E51E1566, // * 2^-509  <  10^-134
    0x915E2486EF32CD60, // * 2^-505  <  10^-133
    0xB5B5ADA8AAFF80B8, // * 2^-502  <  10^-132
    0xE3231912D5BF60E6, // * 2^-499  <  10^-131
    0x8DF5EFABC5979C90, // * 2^-495  >  10^-130
    0xB1736B96B6FD83B4, // * 2^-492  >  10^-129
    0xDDD0467C64BCE4A1, // * 2^-489  >  10^-128
    0x8AA22C0DBEF60EE4, // * 2^-485  <  10^-127
    0xAD4AB7112EB3929E, // * 2^-482  >  10^-126
    0xD89D64D57A607745, // * 2^-479  >  10^-125
    0x87625F056C7C4A8B, // * 2^-475  <  10^-124
    0xA93AF6C6C79B5D2E, // * 2^-472  >  10^-123
    0xD389B47879823479, // * 2^-469  <  10^-122
    0x843610CB4BF160CC, // * 2^-465  >  10^-121
    0xA54394FE1EEDB8FF, // * 2^-462  >  10^-120
    0xCE947A3DA6A9273E, // * 2^-459  <  10^-119
    0x811CCC668829B887, // * 2^-455  <  10^-118
    0xA163FF802A3426A9, // * 2^-452  >  10^-117
    0xC9BCFF6034C13053, // * 2^-449  >  10^-116
    0xFC2C3F3841F17C68, // * 2^-446  >  10^-115
    0x9D9BA7832936EDC1, // * 2^-442  >  10^-114
    0xC5029163F384A931, // * 2^-439  <  10^-113
    0xF64335BCF065D37D, // * 2^-436  <  10^-112
    0x99EA0196163FA42E, // * 2^-432  <  10^-111
    0xC06481FB9BCF8D3A, // * 2^-429  >  10^-110
    0xF07DA27A82C37088, // * 2^-426  <  10^-109
    0x964E858C91BA2655, // * 2^-422  <  10^-108
    0xBBE226EFB628AFEB, // * 2^-419  >  10^-107
    0xEADAB0ABA3B2DBE5, // * 2^-416  <  10^-106
    0x92C8AE6B464FC96F, // * 2^-412  <  10^-105
    0xB77ADA0617E3BBCB, // * 2^-409  <  10^-104
    0xE55990879DDCAABE, // * 2^-406  >  10^-103
    0x8F57FA54C2A9EAB7, // * 2^-402  >  10^-102
    0xB32DF8E9F3546564, // * 2^-399  <  10^-101
    0xDFF9772470297EBD, // * 2^-396  <  10^-100
    0x8BFBEA76C619EF36, // * 2^-392  <  10^-99
    0xAEFAE51477A06B04, // * 2^-389  >  10^-98
    0xDAB99E59958885C5, // * 2^-386  >  10^-97
    0x88B402F7FD75539B, // * 2^-382  <  10^-96
    0xAAE103B5FCD2A882, // * 2^-379  >  10^-95
    0xD59944A37C0752A2, // * 2^-376  <  10^-94
    0x857FCAE62D8493A5, // * 2^-372  <  10^-93
    0xA6DFBD9FB8E5B88F, // * 2^-369  >  10^-92
    0xD097AD07A71F26B2, // * 2^-366  <  10^-91
    0x825ECC24C8737830, // * 2^-362  >  10^-90
    0xA2F67F2DFA90563B, // * 2^-359  <  10^-89
    0xCBB41EF979346BCA, // * 2^-356  <  10^-88
    0xFEA126B7D78186BD, // * 2^-353  >  10^-87
    0x9F24B832E6B0F436, // * 2^-349  <  10^-86
    0xC6EDE63FA05D3144, // * 2^-346  >  10^-85
    0xF8A95FCF88747D94, // * 2^-343  <  10^-84
    0x9B69DBE1B548CE7D, // * 2^-339  >  10^-83
    0xC24452DA229B021C, // * 2^-336  >  10^-82
    0xF2D56790AB41C2A3, // * 2^-333  >  10^-81
    0x97C560BA6B0919A6, // * 2^-329  >  10^-80
    0xBDB6B8E905CB600F, // * 2^-326  <  10^-79
    0xED246723473E3813, // * 2^-323  <  10^-78
    0x9436C0760C86E30C, // * 2^-319  >  10^-77
    0xB94470938FA89BCF, // * 2^-316  >  10^-76
    0xE7958CB87392C2C3, // * 2^-313  >  10^-75
    0x90BD77F3483BB9BA, // * 2^-309  >  10^-74
    0xB4ECD5F01A4AA828, // * 2^-306  <  10^-73
    0xE2280B6C20DD5232, // * 2^-303  <  10^-72
    0x8D590723948A535F, // * 2^-299  <  10^-71
    0xB0AF48EC79ACE837, // * 2^-296  <  10^-70
    0xDCDB1B2798182245, // * 2^-293  >  10^-69
    0x8A08F0F8BF0F156B, // * 2^-289  <  10^-68
    0xAC8B2D36EED2DAC6, // * 2^-286  >  10^-67
    0xD7ADF884AA879177, // * 2^-283  <  10^-66
    0x86CCBB52EA94BAEB, // * 2^-279  >  10^-65
    0xA87FEA27A539E9A5, // * 2^-276  <  10^-64
    0xD29FE4B18E88640F, // * 2^-273  >  10^-63
    0x83A3EEEEF9153E89, // * 2^-269  <  10^-62
    0xA48CEAAAB75A8E2B, // * 2^-266  <  10^-61
    0xCDB02555653131B6, // * 2^-263  <  10^-60
    0x808E17555F3EBF12, // * 2^-259  >  10^-59
    0xA0B19D2AB70E6ED6, // * 2^-256  <  10^-58
    0xC8DE047564D20A8C, // * 2^-253  >  10^-57
    0xFB158592BE068D2F, // * 2^-250  >  10^-56
    0x9CED737BB6C4183D, // * 2^-246  <  10^-55
    0xC428D05AA4751E4D, // * 2^-243  >  10^-54
    0xF53304714D9265E0, // * 2^-240  >  10^-53
    0x993FE2C6D07B7FAC, // * 2^-236  >  10^-52
    0xBF8FDB78849A5F97, // * 2^-233  >  10^-51
    0xEF73D256A5C0F77D, // * 2^-230  >  10^-50
    0x95A8637627989AAE, // * 2^-226  >  10^-49
    0xBB127C53B17EC159, // * 2^-223  <  10^-48
    0xE9D71B689DDE71B0, // * 2^-220  >  10^-47
    0x9226712162AB070E, // * 2^-216  >  10^-46
    0xB6B00D69BB55C8D1, // * 2^-213  <  10^-45
    0xE45C10C42A2B3B06, // * 2^-210  >  10^-44
    0x8EB98A7A9A5B04E3, // * 2^-206  <  10^-43
    0xB267ED1940F1C61C, // * 2^-203  <  10^-42
    0xDF01E85F912E37A3, // * 2^-200  <  10^-41
    0x8B61313BBABCE2C6, // * 2^-196  <  10^-40
    0xAE397D8AA96C1B78, // * 2^-193  >  10^-39
    0xD9C7DCED53C72256, // * 2^-190  >  10^-38
    0x881CEA14545C7575, // * 2^-186  <  10^-37
    0xAA242499697392D3, // * 2^-183  >  10^-36
    0xD4AD2DBFC3D07788, // * 2^-180  >  10^-35
    0x84EC3C97DA624AB5, // * 2^-176  >  10^-34
    0xA6274BBDD0FADD62, // * 2^-173  >  10^-33
    0xCFB11EAD453994BA, // * 2^-170  <  10^-32
    0x81CEB32C4B43FCF5, // * 2^-166  >  10^-31
    0xA2425FF75E14FC32, // * 2^-163  >  10^-30
    0xCAD2F7F5359A3B3E, // * 2^-160  <  10^-29
    0xFD87B5F28300CA0E, // * 2^-157  >  10^-28
    0x9E74D1B791E07E48, // * 2^-153  <  10^-27
    0xC612062576589DDB, // * 2^-150  >  10^-26
    0xF79687AED3EEC551, // * 2^-147  <  10^-25
    0x9ABE14CD44753B53, // * 2^-143  >  10^-24
    0xC16D9A0095928A27, // * 2^-140  <  10^-23
    0xF1C90080BAF72CB1, // * 2^-137  <  10^-22
    0x971DA05074DA7BEF, // * 2^-133  >  10^-21
    0xBCE5086492111AEB, // * 2^-130  >  10^-20
    0xEC1E4A7DB69561A5, // * 2^-127  <  10^-19
    0x9392EE8E921D5D07, // * 2^-123  <  10^-18
    0xB877AA3236A4B449, // * 2^-120  <  10^-17
    0xE69594BEC44DE15B, // * 2^-117  <  10^-16
    0x901D7CF73AB0ACD9, // * 2^-113  <  10^-15
    0xB424DC35095CD80F, // * 2^-110  <  10^-14
    0xE12E13424BB40E13, // * 2^-107  <  10^-13
    0x8CBCCC096F5088CC, // * 2^-103  >  10^-12
    0xAFEBFF0BCB24AAFF, // * 2^-100  >  10^-11
    0xDBE6FECEBDEDD5BF, // * 2^-97   >  10^-10
    0x89705F4136B4A597, // * 2^-93   <  10^-9
    0xABCC77118461CEFD, // * 2^-90   >  10^-8
    0xD6BF94D5E57A42BC, // * 2^-87   <  10^-7
    0x8637BD05AF6C69B6, // * 2^-83   >  10^-6
    0xA7C5AC471B478423, // * 2^-80   <  10^-5
    0xD1B71758E219652C, // * 2^-77   >  10^-4
    0x83126E978D4FDF3B, // * 2^-73   <  10^-3
    0xA3D70A3D70A3D70A, // * 2^-70   <  10^-2
    0xCCCCCCCCCCCCCCCD, // * 2^-67   >  10^-1
    0x8000000000000000, // * 2^-63   == 10^0
    0xA000000000000000, // * 2^-60   == 10^1
    0xC800000000000000, // * 2^-57   == 10^2
    0xFA00000000000000, // * 2^-54   == 10^3
    0x9C40000000000000, // * 2^-50   == 10^4
    0xC350000000000000, // * 2^-47   == 10^5
    0xF424000000000000, // * 2^-44   == 10^6
    0x9896800000000000, // * 2^-40   == 10^7
    0xBEBC200000000000, // * 2^-37   == 10^8
    0xEE6B280000000000, // * 2^-34   == 10^9
    0x9502F90000000000, // * 2^-30   == 10^10
    0xBA43B74000000000, // * 2^-27   == 10^11
    0xE8D4A51000000000, // * 2^-24   == 10^12
    0x9184E72A00000000, // * 2^-20   == 10^13
    0xB5E620F480000000, // * 2^-17   == 10^14
    0xE35FA931A0000000, // * 2^-14   == 10^15
    0x8E1BC9BF04000000, // * 2^-10   == 10^16
    0xB1A2BC2EC5000000, // * 2^-7    == 10^17
    0xDE0B6B3A76400000, // * 2^-4    == 10^18
    0x8AC7230489E80000, // * 2^0     == 10^19
    0xAD78EBC5AC620000, // * 2^3     == 10^20
    0xD8D726B7177A8000, // * 2^6     == 10^21
    0x878678326EAC9000, // * 2^10    == 10^22
    0xA968163F0A57B400, // * 2^13    == 10^23
    0xD3C21BCECCEDA100, // * 2^16    == 10^24
    0x84595161401484A0, // * 2^20    == 10^25
    0xA56FA5B99019A5C8, // * 2^23    == 10^26
    0xCECB8F27F4200F3A, // * 2^26    == 10^27
    0x813F3978F8940984, // * 2^30    <  10^28
    0xA18F07D736B90BE5, // * 2^33    <  10^29
    0xC9F2C9CD04674EDF, // * 2^36    >  10^30
    0xFC6F7C4045812296, // * 2^39    <  10^31
    0x9DC5ADA82B70B59E, // * 2^43    >  10^32
    0xC5371912364CE305, // * 2^46    <  10^33
    0xF684DF56C3E01BC7, // * 2^49    >  10^34
    0x9A130B963A6C115C, // * 2^53    <  10^35
    0xC097CE7BC90715B3, // * 2^56    <  10^36
    0xF0BDC21ABB48DB20, // * 2^59    <  10^37
    0x96769950B50D88F4, // * 2^63    <  10^38
    0xBC143FA4E250EB31, // * 2^66    <  10^39
    0xEB194F8E1AE525FD, // * 2^69    <  10^40
    0x92EFD1B8D0CF37BE, // * 2^73    <  10^41
    0xB7ABC627050305AE, // * 2^76    >  10^42
    0xE596B7B0C643C719, // * 2^79    <  10^43
    0x8F7E32CE7BEA5C70, // * 2^83    >  10^44
    0xB35DBF821AE4F38C, // * 2^86    >  10^45
    0xE0352F62A19E306F, // * 2^89    >  10^46
    0x8C213D9DA502DE45, // * 2^93    <  10^47
    0xAF298D050E4395D7, // * 2^96    >  10^48
    0xDAF3F04651D47B4C, // * 2^99    <  10^49
    0x88D8762BF324CD10, // * 2^103   >  10^50
    0xAB0E93B6EFEE0054, // * 2^106   >  10^51
    0xD5D238A4ABE98068, // * 2^109   <  10^52
    0x85A36366EB71F041, // * 2^113   <  10^53
    0xA70C3C40A64E6C52, // * 2^116   >  10^54
    0xD0CF4B50CFE20766, // * 2^119   >  10^55
    0x82818F1281ED44A0, // * 2^123   >  10^56
    0xA321F2D7226895C8, // * 2^126   >  10^57
    0xCBEA6F8CEB02BB3A, // * 2^129   >  10^58
    0xFEE50B7025C36A08, // * 2^132   <  10^59
    0x9F4F2726179A2245, // * 2^136   <  10^60
    0xC722F0EF9D80AAD6, // * 2^139   <  10^61
    0xF8EBAD2B84E0D58C, // * 2^142   >  10^62
    0x9B934C3B330C8577, // * 2^146   <  10^63
    0xC2781F49FFCFA6D5, // * 2^149   <  10^64
    0xF316271C7FC3908B, // * 2^152   >  10^65
    0x97EDD871CFDA3A57, // * 2^156   >  10^66
    0xBDE94E8E43D0C8EC, // * 2^159   <  10^67
    0xED63A231D4C4FB27, // * 2^162   <  10^68
    0x945E455F24FB1CF9, // * 2^166   >  10^69
    0xB975D6B6EE39E437, // * 2^169   >  10^70
    0xE7D34C64A9C85D44, // * 2^172   <  10^71
    0x90E40FBEEA1D3A4B, // * 2^176   >  10^72
    0xB51D13AEA4A488DD, // * 2^179   <  10^73
    0xE264589A4DCDAB15, // * 2^182   >  10^74
    0x8D7EB76070A08AED, // * 2^186   >  10^75
    0xB0DE65388CC8ADA8, // * 2^189   <  10^76
    0xDD15FE86AFFAD912, // * 2^192   <  10^77
    0x8A2DBF142DFCC7AB, // * 2^196   <  10^78
    0xACB92ED9397BF996, // * 2^199   <  10^79
    0xD7E77A8F87DAF7FC, // * 2^202   >  10^80
    0x86F0AC99B4E8DAFD, // * 2^206   <  10^81
    0xA8ACD7C0222311BD, // * 2^209   >  10^82
    0xD2D80DB02AABD62C, // * 2^212   >  10^83
    0x83C7088E1AAB65DB, // * 2^216   <  10^84
    0xA4B8CAB1A1563F52, // * 2^219   <  10^85
    0xCDE6FD5E09ABCF27, // * 2^222   >  10^86
    0x80B05E5AC60B6178, // * 2^226   <  10^87
    0xA0DC75F1778E39D6, // * 2^229   <  10^88
    0xC913936DD571C84C, // * 2^232   <  10^89
    0xFB5878494ACE3A5F, // * 2^235   <  10^90
    0x9D174B2DCEC0E47B, // * 2^239   <  10^91
    0xC45D1DF942711D9A, // * 2^242   <  10^92
    0xF5746577930D6501, // * 2^245   >  10^93
    0x9968BF6ABBE85F20, // * 2^249   <  10^94
    0xBFC2EF456AE276E9, // * 2^252   >  10^95
    0xEFB3AB16C59B14A3, // * 2^255   >  10^96
    0x95D04AEE3B80ECE6, // * 2^259   >  10^97
    0xBB445DA9CA61281F, // * 2^262   <  10^98
    0xEA1575143CF97227, // * 2^265   >  10^99
    0x924D692CA61BE758, // * 2^269   <  10^100
    0xB6E0C377CFA2E12E, // * 2^272   <  10^101
    0xE498F455C38B997A, // * 2^275   <  10^102
    0x8EDF98B59A373FEC, // * 2^279   <  10^103
    0xB2977EE300C50FE7, // * 2^282   <  10^104
    0xDF3D5E9BC0F653E1, // * 2^285   <  10^105
    0x8B865B215899F46D, // * 2^289   >  10^106
    0xAE67F1E9AEC07188, // * 2^292   >  10^107
    0xDA01EE641A708DEA, // * 2^295   >  10^108
    0x884134FE908658B2, // * 2^299   <  10^109
    0xAA51823E34A7EEDF, // * 2^302   >  10^110
    0xD4E5E2CDC1D1EA96, // * 2^305   <  10^111
    0x850FADC09923329E, // * 2^309   <  10^112
    0xA6539930BF6BFF46, // * 2^312   >  10^113
    0xCFE87F7CEF46FF17, // * 2^315   >  10^114
    0x81F14FAE158C5F6E, // * 2^319   <  10^115
    0xA26DA3999AEF774A, // * 2^322   >  10^116
    0xCB090C8001AB551C, // * 2^325   <  10^117
    0xFDCB4FA002162A63, // * 2^328   <  10^118
    0x9E9F11C4014DDA7E, // * 2^332   <  10^119
    0xC646D63501A1511E, // * 2^335   >  10^120
    0xF7D88BC24209A565, // * 2^338   <  10^121
    0x9AE757596946075F, // * 2^342   <  10^122
    0xC1A12D2FC3978937, // * 2^345   <  10^123
    0xF209787BB47D6B85, // * 2^348   >  10^124
    0x9745EB4D50CE6333, // * 2^352   >  10^125
    0xBD176620A501FC00, // * 2^355   >  10^126
    0xEC5D3FA8CE427B00, // * 2^358   >  10^127
    0x93BA47C980E98CE0, // * 2^362   >  10^128
    0xB8A8D9BBE123F018, // * 2^365   >  10^129
    0xE6D3102AD96CEC1E, // * 2^368   >  10^130
    0x9043EA1AC7E41393, // * 2^372   >  10^131
    0xB454E4A179DD1877, // * 2^375   <  10^132
    0xE16A1DC9D8545E95, // * 2^378   >  10^133
    0x8CE2529E2734BB1D, // * 2^382   <  10^134
    0xB01AE745B101E9E4, // * 2^385   <  10^135
    0xDC21A1171D42645D, // * 2^388   <  10^136
    0x899504AE72497EBA, // * 2^392   <  10^137
    0xABFA45DA0EDBDE69, // * 2^395   <  10^138
    0xD6F8D7509292D603, // * 2^398   <  10^139
    0x865B86925B9BC5C2, // * 2^402   <  10^140
    0xA7F26836F282B733, // * 2^405   >  10^141
    0xD1EF0244AF2364FF, // * 2^408   <  10^142
    0x8335616AED761F1F, // * 2^412   <  10^143
    0xA402B9C5A8D3A6E7, // * 2^415   <  10^144
    0xCD036837130890A1, // * 2^418   <  10^145
    0x802221226BE55A65, // * 2^422   >  10^146
    0xA02AA96B06DEB0FE, // * 2^425   >  10^147
    0xC83553C5C8965D3D, // * 2^428   <  10^148
    0xFA42A8B73ABBF48D, // * 2^431   >  10^149
    0x9C69A97284B578D8, // * 2^435   >  10^150
    0xC38413CF25E2D70E, // * 2^438   >  10^151
    0xF46518C2EF5B8CD1, // * 2^441   <  10^152
    0x98BF2F79D5993803, // * 2^445   >  10^153
    0xBEEEFB584AFF8604, // * 2^448   >  10^154
    0xEEAABA2E5DBF6785, // * 2^451   >  10^155
    0x952AB45CFA97A0B3, // * 2^455   >  10^156
    0xBA756174393D88E0, // * 2^458   >  10^157
    0xE912B9D1478CEB17, // * 2^461   <  10^158
    0x91ABB422CCB812EF, // * 2^465   >  10^159
    0xB616A12B7FE617AA, // * 2^468   <  10^160
    0xE39C49765FDF9D95, // * 2^471   >  10^161
    0x8E41ADE9FBEBC27D, // * 2^475   <  10^162
    0xB1D219647AE6B31C, // * 2^478   <  10^163
    0xDE469FBD99A05FE3, // * 2^481   <  10^164
    0x8AEC23D680043BEE, // * 2^485   <  10^165
    0xADA72CCC20054AEA, // * 2^488   >  10^166
    0xD910F7FF28069DA4, // * 2^491   <  10^167
    0x87AA9AFF79042287, // * 2^495   >  10^168
    0xA99541BF57452B28, // * 2^498   <  10^169
    0xD3FA922F2D1675F2, // * 2^501   <  10^170
    0x847C9B5D7C2E09B7, // * 2^505   <  10^171
    0xA59BC234DB398C25, // * 2^508   <  10^172
    0xCF02B2C21207EF2F, // * 2^511   >  10^173
    0x8161AFB94B44F57D, // * 2^515   <  10^174
    0xA1BA1BA79E1632DC, // * 2^518   <  10^175
    0xCA28A291859BBF93, // * 2^521   <  10^176
    0xFCB2CB35E702AF78, // * 2^524   <  10^177
    0x9DEFBF01B061ADAB, // * 2^528   <  10^178
    0xC56BAEC21C7A1916, // * 2^531   <  10^179
    0xF6C69A72A3989F5C, // * 2^534   >  10^180
    0x9A3C2087A63F6399, // * 2^538   <  10^181
    0xC0CB28A98FCF3C80, // * 2^541   >  10^182
    0xF0FDF2D3F3C30B9F, // * 2^544   <  10^183
    0x969EB7C47859E744, // * 2^548   >  10^184
    0xBC4665B596706115, // * 2^551   >  10^185
    0xEB57FF22FC0C795A, // * 2^554   >  10^186
    0x9316FF75DD87CBD8, // * 2^558   <  10^187
    0xB7DCBF5354E9BECE, // * 2^561   <  10^188
    0xE5D3EF282A242E82, // * 2^564   >  10^189
    0x8FA475791A569D11, // * 2^568   >  10^190
    0xB38D92D760EC4455, // * 2^571   <  10^191
    0xE070F78D3927556B, // * 2^574   >  10^192
    0x8C469AB843B89563, // * 2^578   >  10^193
    0xAF58416654A6BABB, // * 2^581   <  10^194
    0xDB2E51BFE9D0696A, // * 2^584   <  10^195
    0x88FCF317F22241E2, // * 2^588   <  10^196
    0xAB3C2FDDEEAAD25B, // * 2^591   >  10^197
    0xD60B3BD56A5586F2, // * 2^594   >  10^198
    0x85C7056562757457, // * 2^598   >  10^199
    0xA738C6BEBB12D16D, // * 2^601   >  10^200
    0xD106F86E69D785C8, // * 2^604   >  10^201
    0x82A45B450226B39D, // * 2^608   >  10^202
    0xA34D721642B06084, // * 2^611   <  10^203
    0xCC20CE9BD35C78A5, // * 2^614   <  10^204
    0xFF290242C83396CE, // * 2^617   <  10^205
    0x9F79A169BD203E41, // * 2^621   <  10^206
    0xC75809C42C684DD1, // * 2^624   <  10^207
    0xF92E0C3537826146, // * 2^627   >  10^208
    0x9BBCC7A142B17CCC, // * 2^631   >  10^209
    0xC2ABF989935DDBFE, // * 2^634   <  10^210
    0xF356F7EBF83552FE, // * 2^637   <  10^211
    0x98165AF37B2153DF, // * 2^641   >  10^212
    0xBE1BF1B059E9A8D6, // * 2^644   <  10^213
    0xEDA2EE1C7064130C, // * 2^647   <  10^214
    0x9485D4D1C63E8BE8, // * 2^651   >  10^215
    0xB9A74A0637CE2EE1, // * 2^654   <  10^216
    0xE8111C87C5C1BA9A, // * 2^657   >  10^217
    0x910AB1D4DB9914A0, // * 2^661   <  10^218
    0xB54D5E4A127F59C8, // * 2^664   <  10^219
    0xE2A0B5DC971F303A, // * 2^667   <  10^220
    0x8DA471A9DE737E24, // * 2^671   <  10^221
    0xB10D8E1456105DAD, // * 2^674   <  10^222
    0xDD50F1996B947519, // * 2^677   >  10^223
    0x8A5296FFE33CC930, // * 2^681   >  10^224
    0xACE73CBFDC0BFB7B, // * 2^684   <  10^225
    0xD8210BEFD30EFA5A, // * 2^687   <  10^226
    0x8714A775E3E95C78, // * 2^691   <  10^227
    0xA8D9D1535CE3B396, // * 2^694   <  10^228
    0xD31045A8341CA07C, // * 2^697   <  10^229
    0x83EA2B892091E44E, // * 2^701   >  10^230
    0xA4E4B66B68B65D61, // * 2^704   >  10^231
    0xCE1DE40642E3F4B9, // * 2^707   <  10^232
    0x80D2AE83E9CE78F4, // * 2^711   >  10^233
    0xA1075A24E4421731, // * 2^714   >  10^234
    0xC94930AE1D529CFD, // * 2^717   >  10^235
    0xFB9B7CD9A4A7443C, // * 2^720   <  10^236
    0x9D412E0806E88AA6, // * 2^724   >  10^237
    0xC491798A08A2AD4F, // * 2^727   >  10^238
    0xF5B5D7EC8ACB58A3, // * 2^730   >  10^239
    0x9991A6F3D6BF1766, // * 2^734   >  10^240
    0xBFF610B0CC6EDD3F, // * 2^737   <  10^241
    0xEFF394DCFF8A948F, // * 2^740   >  10^242
    0x95F83D0A1FB69CD9, // * 2^744   <  10^243
    0xBB764C4CA7A44410, // * 2^747   >  10^244
    0xEA53DF5FD18D5514, // * 2^750   >  10^245
    0x92746B9BE2F8552C, // * 2^754   <  10^246
    0xB7118682DBB66A77, // * 2^757   <  10^247
    0xE4D5E82392A40515, // * 2^760   <  10^248
    0x8F05B1163BA6832D, // * 2^764   <  10^249
    0xB2C71D5BCA9023F8, // * 2^767   <  10^250
    0xDF78E4B2BD342CF7, // * 2^770   >  10^251
    0x8BAB8EEFB6409C1A, // * 2^774   <  10^252
    0xAE9672ABA3D0C321, // * 2^777   >  10^253
    0xDA3C0F568CC4F3E9, // * 2^780   >  10^254
    0x8865899617FB1871, // * 2^784   <  10^255
    0xAA7EEBFB9DF9DE8E, // * 2^787   >  10^256
    0xD51EA6FA85785631, // * 2^790   <  10^257
    0x8533285C936B35DF, // * 2^794   >  10^258
    0xA67FF273B8460357, // * 2^797   >  10^259
    0xD01FEF10A657842C, // * 2^800   <  10^260
    0x8213F56A67F6B29C, // * 2^804   >  10^261
    0xA298F2C501F45F43, // * 2^807   >  10^262
    0xCB3F2F7642717713, // * 2^810   <  10^263
    0xFE0EFB53D30DD4D8, // * 2^813   >  10^264
    0x9EC95D1463E8A507, // * 2^817   >  10^265
    0xC67BB4597CE2CE49, // * 2^820   >  10^266
    0xF81AA16FDC1B81DB, // * 2^823   >  10^267
    0x9B10A4E5E9913129, // * 2^827   >  10^268
    0xC1D4CE1F63F57D73, // * 2^830   >  10^269
    0xF24A01A73CF2DCD0, // * 2^833   >  10^270
    0x976E41088617CA02, // * 2^837   >  10^271
    0xBD49D14AA79DBC82, // * 2^840   <  10^272
    0xEC9C459D51852BA3, // * 2^843   >  10^273
    0x93E1AB8252F33B46, // * 2^847   >  10^274
    0xB8DA1662E7B00A17, // * 2^850   <  10^275
    0xE7109BFBA19C0C9D, // * 2^853   <  10^276
    0x906A617D450187E2, // * 2^857   <  10^277
    0xB484F9DC9641E9DB, // * 2^860   >  10^278
    0xE1A63853BBD26451, // * 2^863   <  10^279
    0x8D07E33455637EB3, // * 2^867   >  10^280
    0xB049DC016ABC5E60, // * 2^870   >  10^281
    0xDC5C5301C56B75F7, // * 2^873   <  10^282
    0x89B9B3E11B6329BB, // * 2^877   >  10^283
    0xAC2820D9623BF429, // * 2^880   <  10^284
    0xD732290FBACAF134, // * 2^883   >  10^285
    0x867F59A9D4BED6C0, // * 2^887   <  10^286
    0xA81F301449EE8C70, // * 2^890   <  10^287
    0xD226FC195C6A2F8C, // * 2^893   <  10^288
    0x83585D8FD9C25DB8, // * 2^897   >  10^289
    0xA42E74F3D032F526, // * 2^900   >  10^290
    0xCD3A1230C43FB26F, // * 2^903   <  10^291
    0x80444B5E7AA7CF85, // * 2^907   <  10^292
    0xA0555E361951C367, // * 2^910   >  10^293
    0xC86AB5C39FA63441, // * 2^913   >  10^294
    0xFA856334878FC151, // * 2^916   >  10^295
    0x9C935E00D4B9D8D2, // * 2^920   <  10^296
    0xC3B8358109E84F07, // * 2^923   <  10^297
    0xF4A642E14C6262C9, // * 2^926   >  10^298
    0x98E7E9CCCFBD7DBE, // * 2^930   >  10^299
    0xBF21E44003ACDD2D, // * 2^933   >  10^300
    0xEEEA5D5004981478, // * 2^936   <  10^301
    0x95527A5202DF0CCB, // * 2^940   <  10^302
    0xBAA718E68396CFFE, // * 2^943   >  10^303
    0xE950DF20247C83FD, // * 2^946   <  10^304
    0x91D28B7416CDD27E, // * 2^950   <  10^305
    0xB6472E511C81471E, // * 2^953   >  10^306
    0xE3D8F9E563A198E5, // * 2^956   <  10^307
    0x8E679C2F5E44FF8F, // * 2^960   <  10^308
    0xB201833B35D63F73, // * 2^963   <  10^309
    0xDE81E40A034BCF50, // * 2^966   >  10^310
    0x8B112E86420F6192, // * 2^970   >  10^311
    0xADD57A27D29339F6, // * 2^973   <  10^312
    0xD94AD8B1C7380874, // * 2^976   <  10^313
    0x87CEC76F1C830549, // * 2^980   >  10^314
    0xA9C2794AE3A3C69B, // * 2^983   >  10^315
    0xD433179D9C8CB841, // * 2^986   <  10^316
    0x849FEEC281D7F329, // * 2^990   >  10^317
    0xA5C7EA73224DEFF3, // * 2^993   <  10^318
    0xCF39E50FEAE16BF0, // * 2^996   >  10^319
    0x81842F29F2CCE376, // * 2^1000  >  10^320
    0xA1E53AF46F801C53, // * 2^1003  <  10^321
    0xCA5E89B18B602368, // * 2^1006  <  10^322
    0xFCF62C1DEE382C42, // * 2^1009  <  10^323
    0x9E19DB92B4E31BA9, // * 2^1013  <  10^324
};

inline CachedPower GetCachedPower(int index)
{
    CC_ASSERT(index >= 0);
    CC_ASSERT(index < kCachedPowersSize);

    int const k = kCachedPowersMinDecExp + index * kCachedPowersDecExpStep;
    int const e = BinaryExponentFromDecimalExponent(k);

    return {kCachedPowersSignificands[index], e, k};
}

// Returns a cached power of ten x ~= 10^k such that
//  k <= e < k + kCachedPowersDecExpStep.
//
// PRE: e >= kCachedPowersMinDecExp
// PRE: e <  kCachedPowersMaxDecExp + kCachedPowersDecExpStep
inline CachedPower GetCachedPowerForDecimalExponent(int e)
{
    CC_ASSERT(e >= kCachedPowersMinDecExp);
    CC_ASSERT(e <  kCachedPowersMaxDecExp + kCachedPowersDecExpStep);

    int const index = static_cast<int>( static_cast<unsigned>(-kCachedPowersMinDecExp + e) / kCachedPowersDecExpStep );
    CC_ASSERT(index >= 0);
    CC_ASSERT(index < kCachedPowersSize);

    auto const cached = GetCachedPower(index);
    CC_ASSERT(e >= cached.k);
    CC_ASSERT(e <  cached.k + kCachedPowersDecExpStep);

    return cached;
}

// Max double: 1.7976931348623157 * 10^308, which has 309 digits.
// Any x >= 10^309 is interpreted as +infinity.
constexpr int kMaxDecimalPower = 309;

// Min non-zero double: 4.9406564584124654 * 10^-324
// Any x <= 10^-324 is interpreted as 0.
// Note that 2.5e-324 (despite being smaller than the min double) will be read
// as non-zero (equal to the min non-zero double).
constexpr int kMinDecimalPower = -324;

// Returns the significand size for a given order of magnitude.
//
// If v = f * 2^e with 2^(q-1) <= f < 2^q then (q+e) is v's order of magnitude.
// If v = s * 2^e with 1/2 <= s < 1 then e is v's order of magnitude.
//
// This function returns the number of significant binary digits v will have
// once it's encoded into a 'double'. In almost all cases this is equal to
// Double::SignificandSize. The only exceptions are subnormals. They start with
// leading zeroes and their effective significand-size is hence smaller.
inline int EffectiveSignificandSize(int order)
{
    int const s = order - Double::MinExponent;

    if (s > Double::SignificandSize)
        return Double::SignificandSize;
    if (s < 0)
        return 0;

    return s;
}

// Returns `f * 2^e`.
inline double LoadFloat(uint64_t f, int e)
{
    CC_ASSERT(f <= Double::HiddenBit + Double::SignificandMask);
    CC_ASSERT(e <= Double::MinExponent || (f & Double::HiddenBit) != 0);

    if (e < Double::MinExponent)
        return 0;
    if (e > Double::MaxExponent)
        return std::numeric_limits<double>::infinity();

    bool const is_subnormal = (e == Double::MinExponent && (f & Double::HiddenBit) == 0);

    uint64_t const exponent = is_subnormal
        ? 0
        : static_cast<uint64_t>(e + Double::ExponentBias);

    return Double((exponent << Double::PhysicalSignificandSize) | (f & Double::SignificandMask)).Value();
}

// Use DiyFp's to approximate digits * 10^exponent.
//
// If the function returns true then 'result' is the correct double.
// Otherwise 'result' is either the correct double or the double that is just
// below the correct double.
//
// PRE: num_digits + exponent <= kMaxDecimalPower
// PRE: num_digits + exponent >  kMinDecimalPower
inline bool StrtodApprox(double& result, char const* digits, int num_digits, int exponent)
{
    static_assert(DiyFp::SignificandSize == 64,
        "We use uint64's. This only works if the DiyFp uses uint64's too.");

    CC_ASSERT(num_digits > 0);
    CC_ASSERT(DigitValue(digits[0]) > 0);
//  CC_ASSERT(DigitValue(digits[num_digits - 1]) > 0);
    CC_ASSERT(num_digits + exponent <= kMaxDecimalPower);
    CC_ASSERT(num_digits + exponent >  kMinDecimalPower);

    // Compute an approximation 'input' for B = digits * 10^exponent using DiyFp's.
    // And keep track of the error.
    //
    //                       <-- error -->
    //                               B = digits * 10^exponent
    //  ---------(-----------|-------+---)------------------------------------
    //                       x
    //                       ~= (f * 2^e) * 10^exponent

    int const read_digits = Min(num_digits, std::numeric_limits<uint64_t>::digits10);

    DiyFpWithError input;

    input.x.f = ReadInt<uint64_t>(digits, read_digits);
    input.x.e = 0;
    input.error = 0;

    if (FastPath(result, input.x.f, num_digits, exponent))
        return true;

    constexpr uint32_t ULP = DiyFpWithError::Denominator;
    constexpr uint32_t InitialError = ULP / 2;

    if (read_digits < num_digits)
    {
        // Round.
        input.x.f += (DigitValue(digits[read_digits]) >= 5);
        // The error is <= 1/2 ULP.
        input.error = InitialError;
    }

    // x = f * 2^0

    // Normalize x and scale the error, such that 'error' is in ULP(x).
    Normalize(input);

    // If the input is exact, error == 0.
    // If the input is inexact, we have read 19 digits, i.e., f >= 10^(19-1) > 2^59.
    // The scaling factor in the normalization step above therefore is <= 2^(63-59) = 2^4.
    CC_ASSERT(input.error <= 16 * InitialError);

    // Move the remaining decimals into the (decimal) exponent.
    exponent += num_digits - read_digits;

    // Let x and y be normalized floating-point numbers
    //
    //      x = f_x * 2^e_x,    2^(q-1) <= f_x < 2^q
    //      y = f_y * 2^e_y,    2^(q-1) <= f_y < 2^q
    //
    // Then
    //
    //      z = Multiply(x,y) = f_z * 2^e_z
    //
    // returns the floating-point number closest to the product x*y. The result
    // z is not neccessarily normalized, but the error is bounded by 1/2 ulp,
    // i.e.,
    //
    //      |x*y - z| <= 1/2 ulp
    //
    // or
    //
    //      x*y = (f_z + eps_z) * 2^e_z,    |eps_z| <= 1/2, e_z = e_x + e_y + q.
    //
    // If x and y are approximations to real numbers X and Y, i.e.,
    //
    //      X = (f_x + eps_x) * 2^e_x,      |eps_x| <= err_x,
    //      Y = (f_y + eps_y) * 2^e_y,      |eps_y| <= err_y,
    //
    // then the error introduced by a multiplication Multiply(x,y) is (see [1])
    //
    //      |X*Y - z| <= 1/2 + err_x + err_y + (err_x * err_y - err_x - err_y) / 2^q
    //
    // And if err_x < 1 (or err_y < 1), then
    //
    //      |X*Y - z| <= 1/2 + (err_x + err_y)

    auto const cached = GetCachedPowerForDecimalExponent(exponent);
    auto const cached_power = DiyFp(cached.f, cached.e);

    CC_ASSERT(IsNormalized(input.x));
    CC_ASSERT(IsNormalized(cached_power));

    input.x = Multiply(input.x, cached_power);
    // x ~= digits * 10^exponent

    // Adjust the error.
    // Since all cached powers have an error of less than 1/2 ulp, err_y = 1/2,
    // and the error is therefore less than 1/2 + (err_x + err_y).

#if 1
    input.error += ULP / 2 + (0 <= exponent && exponent <= 27 ? 0 : ULP / 2);
#else
    input.error += ULP / 2 + ULP / 2;
#endif
    CC_ASSERT(input.error <= 16 * InitialError + 2 * (ULP / 2));

    // The result of the multiplication might not be normalized.
    // Normalize 'x' again and scale the error.
    Normalize(input);

    // Since both factors were normalized, the scaling factor in the
    // normalization step above is bounded by 2^1.
    CC_ASSERT(input.error <= 2 * (16 * InitialError + 2 * (ULP / 2)));

    // We now have an approximation x = f * 2^e ~= digits * 10^exponent.
    //
    //                       <-- error -->
    //                               B = digits * 10^exponent
    //  ---------(-----------|-------+---)------------------------------------
    //                       x
    //                       ~= digits * 10^exponent
    //
    // B = (x.f + delta) * 2^x.e, where |delta| <= error / kULP
    //
    // When converting f * 2^e, which has a q-bit significand, into an IEEE
    // double-precision number, we need to drop some 'excess_bits' bits of
    // precision.

    int const prec = EffectiveSignificandSize(DiyFp::SignificandSize + input.x.e);
    CC_ASSERT(prec >= 0);
    CC_ASSERT(prec <= 53);

    int const excess_bits = DiyFp::SignificandSize - prec;

    // n = excess_bits
    //
    // f = (f div 2^n) * 2^n + (f mod 2^n)
    //   = (p1       ) * 2^n + (p2       )
    //
    //                             f = p1 * 2^n + p2
    //   <--- p2 ------------------>
    //                 <-- error --+-- error -->
    // --|-------------(-----------+------|----)---------------------------|--
    //   p1 * 2^n                                                 (p1 + 1) * 2^n
    //   <------------- half ------------->
    //                  = 2^n / 2
    //
    // The correct double now is either p1 * 2^(e + n) or (p1 + 1) * 2^(e + n).
    // See [1], Theorem 11.
    //
    // In case p2 + error < half, we can safely round down. If p2 - error > half
    // we can safely round up. Otherwise, we are too inaccurate. In this case
    // we round down, so the returned double is either the correct double or the
    // double just below the correct double. In this case we return false, so
    // that the we can fall back to a more precise algorithm.

    CC_ASSERT(excess_bits >= 11);
    CC_ASSERT(excess_bits <= 64);

    uint64_t const p2 = (excess_bits < 64) ? (input.x.f & ((uint64_t{1} << excess_bits) - 1)) : input.x.f;
    uint64_t const half = uint64_t{1} << (excess_bits - 1);

    // Truncate the significand to p = q - n bits and move the discarded bits
    // into the (binary) exponent.
    // (Right shift of >= bit-width is undefined.)
    input.x.f = (excess_bits < 64) ? (input.x.f >> excess_bits) : 0;
    input.x.e += excess_bits;

    // Split up error into high (integral) and low (fractional) parts,
    // since half * kULP might overflow.
    uint32_t const error_hi = input.error / ULP;
    uint32_t const error_lo = input.error % ULP;

    CC_ASSERT(input.error > 0);
    CC_ASSERT(half >= error_hi && half - error_hi <= UINT64_MAX / ULP && (half - error_hi) * ULP >= error_lo);
    CC_ASSERT(half <= UINT64_MAX - error_hi);
    static_cast<void>(error_lo);

    // Note:
    // Since error is non-zero, we can safely use '<=' and '>=' in the
    // comparisons below.

    bool success;
#if 1
    // p2 * U >= half * U + error
    // <=> p2 * U >= half * U + (error_hi * U + error_lo)
    // <=> p2 * U >= (half + error_hi) * U + error_lo
    // <=> p2 >= (half + error_hi) + error_lo / U
    if (p2 > half + error_hi)
#else
    if (p2 * ULP >= half * ULP + input.error)
#endif
    {
        // Round up.
        success = true;

        ++input.x.f;

        // Rounding up may overflow the p-bit significand.
        // But in this case the significand is 2^53 and we don't loose any
        // bits by normalizing 'input' (we just move a factor of 2 into the
        // binary exponent).
        if (input.x.f > Double::HiddenBit + Double::SignificandMask)
        {
            CC_ASSERT(input.x.f == (Double::HiddenBit << 1));

            input.x.f >>= 1;
            input.x.e  += 1;
        }
    }
#if 1
    // p2 * U <= half * U - error
    // <=> half * U >= p2 * U + error
    // <=> half * U >= p2 * U + (error_hi * U + error_lo)
    // <=> half * U >= (p2 + error_hi) * U + error_lo
    // <=> half >= (p2 + error_hi) + error_lo / U
    else if (half > p2 + error_hi)
#else
    else if (p2 * ULP <= half * ULP - input.error)
#endif
    {
        // Round down.
        success = true;
    }
    else
    {
        // Too imprecise.
        // Round down and return false, so that we can fall back to a more
        // precise algorithm.
        success = false;
    }

    result = LoadFloat(input.x.f, input.x.e);
    return success;
}

inline bool ComputeGuess(double& result, char const* digits, int num_digits, int exponent)
{
    CC_ASSERT(num_digits > 0);
    CC_ASSERT(num_digits <= kMaxSignificantDigits);
    CC_ASSERT(DigitValue(digits[0]) > 0);
//  CC_ASSERT(DigitValue(digits[num_digits - 1]) > 0);

    // Any v >= 10^309 is interpreted as +Infinity.
    if (num_digits + exponent > kMaxDecimalPower)
    {
        // Overflow.
        result = std::numeric_limits<double>::infinity();
        return true;
    }

    // Any v <= 10^-324 is interpreted as 0.
    if (num_digits + exponent <= kMinDecimalPower)
    {
        // Underflow.
        result = 0;
        return true;
    }

    return StrtodApprox(result, digits, num_digits, exponent);
}

//--------------------------------------------------------------------------------------------------
// StrtodBignum
//--------------------------------------------------------------------------------------------------

struct DiyInt // bigits * 2^exponent
{
    static constexpr int MaxBits = 64 + 2536 /*log_2(5^(324 - 1 + 769))*/ + 32;
    static constexpr int Capacity = (MaxBits + (32 - 1)) / 32;

    uint32_t bigits[Capacity]; // Significand stored in little-endian form.
    int      size = 0;
    int      exponent = 0;

    DiyInt() = default;
    DiyInt(DiyInt const&) = delete;             // (not needed here)
    DiyInt& operator=(DiyInt const&) = delete;  // (not needed here)
};

inline void AssignZero(DiyInt& x)
{
    x.size = 0;
    x.exponent = 0;
}

inline void AssignU32(DiyInt& x, uint32_t value)
{
    AssignZero(x);

    if (value == 0)
        return;

    x.bigits[0] = value;
    x.size = 1;
}

inline void AssignU64(DiyInt& x, uint64_t value)
{
    AssignZero(x);

    if (value == 0)
        return;

    x.bigits[0] = static_cast<uint32_t>(value);
    x.bigits[1] = static_cast<uint32_t>(value >> 32);
    x.size = (x.bigits[1] == 0) ? 1 : 2;
}

// x := A * x + B
inline void MulAddU32(DiyInt& x, uint32_t A, uint32_t B = 0)
{
    CC_ASSERT(B == 0 || x.exponent == 0);

    if (A == 1 && B == 0)
    {
        return;
    }
    if (A == 0 || x.size == 0)
    {
        AssignU32(x, B);
        return;
    }

    uint32_t carry = B;
    for (int i = 0; i < x.size; ++i)
    {
        uint64_t const p = uint64_t{x.bigits[i]} * A + carry;
        x.bigits[i]      = static_cast<uint32_t>(p);
        carry            = static_cast<uint32_t>(p >> 32);
    }

    if (carry != 0)
    {
        CC_ASSERT(x.size < DiyInt::Capacity);
        x.bigits[x.size++] = carry;
    }
}

inline void AssignDecimalDigits(DiyInt& x, char const* digits, int num_digits)
{
    static constexpr uint32_t kPow10_32[] = {
        1, // (unused)
        10,
        100,
        1000,
        10000,
        100000,
        1000000,
        10000000,
        100000000,
        1000000000, // 10^9
    };

    AssignZero(x);

    while (num_digits > 0)
    {
        int const n = Min(num_digits, 9);
        MulAddU32(x, kPow10_32[n], ReadInt<uint32_t>(digits, n));
        digits     += n;
        num_digits -= n;
    }
}

inline void MulPow2(DiyInt& x, int exp) // aka left-shift
{
    CC_ASSERT(exp >= 0);

    if (x.size == 0)
        return;
    if (exp == 0)
        return;

    int const bigit_shift = static_cast<int>(static_cast<uint32_t>(exp)) / 32;
    int const bit_shift   = static_cast<int>(static_cast<uint32_t>(exp)) % 32;

    if (bit_shift > 0)
    {
        uint32_t carry = 0;
        for (int i = 0; i < x.size; ++i)
        {
            uint32_t const h = x.bigits[i] >> (32 - bit_shift);
            x.bigits[i]      = x.bigits[i] << bit_shift | carry;
            carry            = h;
        }

        if (carry != 0)
        {
            CC_ASSERT(x.size < DiyInt::Capacity);
            x.bigits[x.size++] = carry;
        }
    }

    x.exponent += bigit_shift;
}

inline void MulPow5(DiyInt& x, int exp)
{
    static constexpr uint32_t kPow5_32[] = {
        1, // (unused)
        5,
        25,
        125,
        625,
        3125,
        15625,
        78125,
        390625,
        1953125,
        9765625,
        48828125,
        244140625,
        1220703125, // 5^13
    };

    if (x.size == 0)
        return;

    CC_ASSERT(exp >= 0);
    if (exp == 0)
        return;

    while (exp > 0)
    {
        int const n = Min(exp, 13);
        MulAddU32(x, kPow5_32[n]);
        exp -= n;
    }
}

inline int Compare(DiyInt const& lhs, DiyInt const& rhs)
{
    int const e1 = lhs.exponent;
    int const e2 = rhs.exponent;
    int const n1 = lhs.size + e1;
    int const n2 = rhs.size + e2;

    if (n1 < n2) return -1;
    if (n1 > n2) return +1;

    for (int i = n1 - 1; i >= Min(e1, e2); --i)
    {
        uint32_t const b1 = (i - e1) >= 0 ? lhs.bigits[i - e1] : 0;
        uint32_t const b2 = (i - e2) >= 0 ? rhs.bigits[i - e2] : 0;

        if (b1 < b2) return -1;
        if (b1 > b2) return +1;
    }

    return 0;
}

// Compare digits * 10^exponent with v = f * 2^e.
//
// PRE: num_digits + exponent <= kMaxDecimalPower
// PRE: num_digits + exponent >  kMinDecimalPower
// PRE: num_digits            <= kMaxSignificantDigits
inline int CompareBufferWithDiyFp(char const* digits, int num_digits, int exponent, bool nonzero_tail, DiyFp v)
{
    CC_ASSERT(num_digits > 0);
    CC_ASSERT(num_digits + exponent <= kMaxDecimalPower);
    CC_ASSERT(num_digits + exponent >  kMinDecimalPower);
    CC_ASSERT(num_digits            <= kMaxSignificantDigits);

    DiyInt lhs;
    DiyInt rhs;

    AssignDecimalDigits(lhs, digits, num_digits);
    if (nonzero_tail)
    {
        MulAddU32(lhs, 10, 1);
        exponent--;
    }
    AssignU64(rhs, v.f);

    CC_ASSERT(lhs.size <= (2555 + 31) / 32); // bits <= log_2(10^769) = 2555
    CC_ASSERT(rhs.size <= (  64 + 31) / 32); // bits <= 64

    int lhs_exp5 = 0;
    int rhs_exp5 = 0;
    int lhs_exp2 = 0;
    int rhs_exp2 = 0;

    if (exponent >= 0)
    {
        lhs_exp5 += exponent;
        lhs_exp2 += exponent;
    }
    else
    {
        rhs_exp5 -= exponent;
        rhs_exp2 -= exponent;
    }

    if (v.e >= 0)
    {
        rhs_exp2 += v.e;
    }
    else
    {
        lhs_exp2 -= v.e;
    }

#if 1
    if (lhs_exp5 > 0 || rhs_exp5 > 0)
    {
        MulPow5((lhs_exp5 > 0) ? lhs : rhs, (lhs_exp5 > 0) ? lhs_exp5 : rhs_exp5);
    }
#else
    if (lhs_exp5 > 0) // rhs >= digits
    {
        MulPow5(lhs, lhs_exp5);

        // num_digits + exponent <= kMaxDecimalPower + 1
        CC_ASSERT(lhs.size <= (1030 + 31) / 32);  // 1030 = log_2(10^(309 + 1)))
        CC_ASSERT(rhs.size <= (  64 + 31) / 32);
    }
    else if (rhs_exp5 > 0)
    {
        MulPow5(rhs, rhs_exp5);

        // kMinDecimalPower + 1 <= num_digits + exponent <= kMaxDecimalPower + 1
        // rhs_exp5 = -exponent <= -kMinDecimalPower - 1 + num_digits = 324 - 1 + num_digits <= 324 - 1 + 769
        // rhs_exp5 = -exponent >= -kMaxDecimalPower - 1 + num_digits
        CC_ASSERT(lhs.size <= (2555        + 31) / 32);
        CC_ASSERT(rhs.size <= (  64 + 2536 + 31) / 32); // 2536 = log_2(5^(324 - 1 + 769)) ---- XXX: 2504
    }
#endif

#if 0
    // Cancel common factors of 2.
    int const min_exp2 = Min(lhs_exp2, rhs_exp2);
    lhs_exp2 -= min_exp2;
    rhs_exp2 -= min_exp2;

    MulPow2(lhs, lhs_exp2);
    MulPow2(rhs, rhs_exp2);
#else
#if 1
    int const diff_exp2 = lhs_exp2 - rhs_exp2;
    if (diff_exp2 != 0)
    {
        MulPow2((diff_exp2 > 0) ? lhs : rhs, (diff_exp2 > 0) ? diff_exp2 : -diff_exp2);
    }
#else
    if (lhs_exp2 > rhs_exp2)
    {
        MulPow2(lhs, lhs_exp2 - rhs_exp2);
    }
    else if (rhs_exp2 > lhs_exp2)
    {
        MulPow2(rhs, rhs_exp2 - lhs_exp2);
    }
#endif
#endif

    CC_ASSERT(lhs.size <= (2555        + 32 + 31) / 32);
    CC_ASSERT(rhs.size <= (  64 + 2536 + 32 + 31) / 32);

    return Compare(lhs, rhs);
}

//--------------------------------------------------------------------------------------------------
// DigitsToIEEE
//--------------------------------------------------------------------------------------------------

inline bool SignificandIsEven(double v)
{
//  return (Double(v).PhysicalSignificand() & 1) == 0;
    return (Double(v).bits & 1) == 0;
}

// Returns the next larger double-precision value.
// If v is +Infinity returns v.
inline double NextLarger(double v)
{
    return Double(v).NextValue();
}

// Convert the decimal representation 'digits * 10^exponent' into an IEEE
// double-precision number.
//
// PRE: digits must contain only ASCII characters in the range '0'...'9'.
// PRE: num_digits >= 0
// PRE: num_digits + exponent must not overflow.
inline double DigitsToDouble(char const* digits, int num_digits, int exponent, bool nonzero_tail = false)
{
    CC_ASSERT(num_digits >= 0);
    CC_ASSERT(exponent <= INT_MAX - num_digits);

    // Ignore leading zeros
    while (num_digits > 0 && digits[0] == '0')
    {
        digits++;
        num_digits--;
    }

    // Move trailing zeros into the exponent
    if (!nonzero_tail)
    {
        while (num_digits > 0 && digits[num_digits - 1] == '0')
        {
            num_digits--;
            exponent++;
        }
    }

    if (num_digits > kMaxSignificantDigits)
    {
        // Since trailing zeros have been trimmed above:
        CC_ASSERT(nonzero_tail || DigitValue(digits[num_digits - 1]) > 0);

        nonzero_tail = true;

        // Discard insignificant digits.
        exponent += num_digits - kMaxSignificantDigits;
        num_digits = kMaxSignificantDigits;
    }

    if (num_digits == 0)
    {
        return 0;
    }

    double v;
    if (ComputeGuess(v, digits, num_digits, exponent))
    {
        return v;
    }

    // Now v is either the correct or the next-lower double (i.e. the correct
    // double is v+).
    // Compare B = buffer * 10^exponent with v's upper boundary m+.
    //
    //     v             m+            v+
    //  ---+--------+----+-------------+---
    //              B

    int const cmp = CompareBufferWithDiyFp(digits, num_digits, exponent, nonzero_tail, UpperBoundary(v));
    if (cmp < 0 || (cmp == 0 && SignificandIsEven(v)))
    {
        return v;
    }
    return NextLarger(v);
}

} // namespace charconv_internal
